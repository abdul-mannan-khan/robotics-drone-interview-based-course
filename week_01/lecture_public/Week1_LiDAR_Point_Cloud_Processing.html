<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robotics & Drone Engineering Week 1: LiDAR Point Cloud Processing Fundamentals</title>
    <style>
        @page {
            size: A4;
            margin: 2cm;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .page {
            width: 21cm;
            min-height: 29.7cm;
            padding: 2cm;
            margin: 20px auto;
            background: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            page-break-after: always;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        h2 {
            color: #667eea;
            border-bottom: 3px solid #764ba2;
            padding-bottom: 10px;
            margin: 30px 0 20px 0;
            font-size: 1.8em;
        }

        h3 {
            color: #764ba2;
            margin: 25px 0 15px 0;
            font-size: 1.4em;
        }

        h4 {
            color: #667eea;
            margin: 20px 0 10px 0;
            font-size: 1.2em;
        }

        .info-box {
            background: #e8f4f8;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff4e6;
            border-left: 5px solid #ff9800;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .activity-box {
            background: #f0f8ff;
            border: 3px solid #4CAF50;
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }

        .activity-box h3 {
            color: #4CAF50;
            margin-top: 0;
        }

        .image-container {
            text-align: center;
            margin: 30px 0;
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .image-caption {
            font-style: italic;
            color: #666;
            margin-top: 10px;
            font-size: 0.9em;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin: 8px 0;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .checklist {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .checklist li {
            list-style: none;
            padding: 8px 0;
        }

        .checklist li:before {
            content: "\2713 ";
            color: #4CAF50;
            font-weight: bold;
            margin-right: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            table-layout: fixed;
            word-wrap: break-word;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        th {
            background: #667eea;
            color: white;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        .diagram {
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            background: white;
        }

        .flow-step {
            background: #667eea;
            color: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
        }

        .arrow {
            text-align: center;
            font-size: 2em;
            color: #764ba2;
            margin: 5px 0;
        }

        .tip {
            background: #fffbea;
            border-left: 5px solid #ffd700;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .tip:before {
            content: "\1F4A1 TIP: ";
            font-weight: bold;
            color: #ff9800;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
        }

        img { max-width: 100%; height: auto; }
        svg { max-width: 100%; height: auto; }
        .math { overflow-x: auto; }
        .two-column > *, .three-column > * { min-width: 0; overflow: hidden; word-wrap: break-word; }

        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            max-width: 100%;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        pre .comment { color: #6a9955; }
        pre .keyword { color: #569cd6; }
        pre .string { color: #ce9178; }
        pre .function { color: #dcdcaa; }
        pre .number { color: #b5cea8; }

        .example-box {
            background: #f0fff0;
            border: 2px dashed #4CAF50;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .footer {
            text-align: center;
            color: #666;
            padding: 20px;
            margin-top: 30px;
            border-top: 2px solid #eee;
        }

        .math {
            background: #f8f8ff;
            border: 1px solid #667eea;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            text-align: center;
            font-size: 1.1em;
        }

        @media print {
            body {
                background: white;
            }
            .page {
                margin: 0;
                box-shadow: none;
            }
        }
    </style>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']]
            },
            svg: { fontCache: 'global' }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
</head>
<body>

<!-- PAGE 1: TITLE AND INTRODUCTION -->
<div class="page">
    <div class="header">
        <h1>Week 1: LiDAR Point Cloud Processing</h1>
        <h2 style="color: white; border: none; margin: 20px 0;">3D Obstacle Detection Pipeline</h2>
        
        <p>Dr. Abdul Manan Khan</p>
        <p>Duration: 6 Hours | Category: PERCEPTION | Priority: CRITICAL</p>
    </div>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1558618666-fcd25c85f82e?w=800" alt="LiDAR Point Cloud">
        <p class="image-caption">LiDAR sensors generate 3D point clouds used for obstacle detection in autonomous vehicles and drones</p>
    </div>

    <h2>Lecture Overview</h2>
    <div class="info-box">
        <h3>Learning Objectives</h3>
        <p>By the end of this lecture, you will be able to:</p>
        <ul>
            <li>Understand LiDAR technology and point cloud data structures (PCD, PLY, NumPy)</li>
            <li>Implement voxel grid downsampling for computational efficiency</li>
            <li>Apply RANSAC algorithm for ground plane segmentation</li>
            <li>Build a KD-Tree for efficient nearest neighbour search</li>
            <li>Perform Euclidean clustering and DBSCAN for object segmentation</li>
            <li>Fit axis-aligned and oriented bounding boxes using PCA</li>
            <li>Evaluate detection quality using Intersection over Union (IoU)</li>
            <li>Integrate all stages into a real-time obstacle detection pipeline</li>
        </ul>
    </div>

    <h3>Session Structure</h3>
    <table>
        <tr>
            <th>Time</th>
            <th>Topic</th>
            <th>Duration</th>
        </tr>
        <tr>
            <td>0:00 - 1:00</td>
            <td>Introduction to LiDAR &amp; Point Cloud Preprocessing</td>
            <td>60 min</td>
        </tr>
        <tr>
            <td>1:00 - 2:00</td>
            <td>RANSAC Ground Segmentation &amp; KD-Trees</td>
            <td>60 min</td>
        </tr>
        <tr>
            <td>2:00 - 2:15</td>
            <td>BREAK</td>
            <td>15 min</td>
        </tr>
        <tr>
            <td>2:15 - 3:15</td>
            <td>Clustering &amp; Bounding Box Fitting</td>
            <td>60 min</td>
        </tr>
        <tr>
            <td>3:15 - 4:15</td>
            <td>Full Pipeline Integration &amp; Lab Work</td>
            <td>60 min</td>
        </tr>
        <tr>
            <td>4:15 - 6:00</td>
            <td>Hands-On Lab: Complete Pipeline Implementation</td>
            <td>105 min</td>
        </tr>
    </table>

    <div class="warning-box">
        <h4>Target Companies</h4>
        <p><strong>Waymo</strong> | <strong>Cruise</strong> | <strong>Aurora</strong> | <strong>Skydio</strong> | <strong>DJI</strong></p>
        <p>This is the most common perception interview challenge at autonomous vehicle and drone companies.</p>
    </div>
</div>

<!-- PAGE 2: INTRODUCTION TO LIDAR -->
<div class="page">
    <h2>Part 1: Introduction to LiDAR (60 minutes)</h2>

    <h3>What is LiDAR?</h3>
    <p><strong>LiDAR</strong> (Light Detection and Ranging) is an active sensing technology that measures distances by illuminating targets with laser light and measuring the reflected pulses with a sensor.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1601134467661-3d775b999c8b?w=800" alt="Autonomous Vehicle Sensors">
        <p class="image-caption">LiDAR sensors on autonomous vehicles provide direct 3D measurements of the environment</p>
    </div>

    <div class="two-column">
        <div class="info-box">
            <h4>Key Properties</h4>
            <ul>
                <li><strong>Direct 3D:</strong> Unlike cameras (2D projections)</li>
                <li><strong>Lighting invariant:</strong> Works in darkness</li>
                <li><strong>Range:</strong> 10m to 200m+</li>
                <li><strong>Angular resolution:</strong> 0.1&deg; to 0.4&deg;</li>
                <li><strong>Density:</strong> Thousands to millions of points/scan</li>
            </ul>
        </div>

        <div class="warning-box">
            <h4>Limitations</h4>
            <ul>
                <li>No colour/texture information</li>
                <li>Affected by rain, fog, dust</li>
                <li>Expensive (though costs are dropping)</li>
                <li>Sparse at long range</li>
                <li>Reflective surfaces cause artefacts</li>
            </ul>
        </div>
    </div>

    <h3>Types of LiDAR Sensors</h3>
    <table>
        <tr>
            <th>Type</th>
            <th>Example</th>
            <th>Points/sec</th>
            <th>Range</th>
            <th>Use Case</th>
        </tr>
        <tr>
            <td><strong>2D Scanning</strong></td>
            <td>RPLiDAR S2</td>
            <td>32,000</td>
            <td>30m</td>
            <td>Mobile robots, SLAM</td>
        </tr>
        <tr>
            <td><strong>3D Spinning</strong></td>
            <td>Velodyne VLP-16</td>
            <td>300,000</td>
            <td>100m</td>
            <td>Autonomous vehicles</td>
        </tr>
        <tr>
            <td><strong>Solid-State</strong></td>
            <td>Livox Mid-360</td>
            <td>200,000</td>
            <td>40m</td>
            <td>Drones, compact robots</td>
        </tr>
        <tr>
            <td><strong>Flash</strong></td>
            <td>Continental HFL110</td>
            <td>N/A</td>
            <td>30m</td>
            <td>Automotive ADAS</td>
        </tr>
    </table>

    <h3>Point Cloud Data</h3>
    <div class="info-box">
        <p>A point cloud is a set of 3D points:</p>
        <div class="math">\[ P = \{ p_i \mid p_i = (x_i, y_i, z_i, I_i) \}, \quad i = 1, \ldots, N \]</div>
        <ul>
            <li>\((x, y, z)\) = 3D coordinates in the sensor frame</li>
            <li>\(I\) = intensity (reflectivity of the surface)</li>
            <li>\(N\) = number of points (typically 10K&ndash;1M per scan)</li>
        </ul>
    </div>

    <h4>Common File Formats:</h4>
    <table>
        <tr>
            <th>Format</th>
            <th>Description</th>
            <th>Typical Use</th>
        </tr>
        <tr>
            <td><strong>PCD</strong></td>
            <td>Point Cloud Data &ndash; PCL native format</td>
            <td>C++ with PCL library</td>
        </tr>
        <tr>
            <td><strong>PLY</strong></td>
            <td>Polygon File Format &ndash; widely supported</td>
            <td>3D modelling, Open3D</td>
        </tr>
        <tr>
            <td><strong>LAS/LAZ</strong></td>
            <td>Standard for aerial LiDAR (compressed)</td>
            <td>Surveying, GIS</td>
        </tr>
        <tr>
            <td><strong>NumPy .npy</strong></td>
            <td>Binary array format</td>
            <td>Python workflows</td>
        </tr>
    </table>
</div>

<!-- PAGE 3: VOXEL DOWNSAMPLING -->
<div class="page">
    <h3>Voxel Grid Downsampling</h3>

    <div class="info-box">
        <h4>Problem</h4>
        <p>Raw point clouds are too dense for real-time processing. A single Velodyne VLP-16 scan produces 300,000 points per second. We need to reduce this while preserving geometric structure.</p>
    </div>

    <div class="image-container">
        <svg width="650" height="280" style="max-width: 100%;">
            <!-- Original dense cloud -->
            <rect x="20" y="20" width="260" height="240" fill="#f0f0f0" stroke="#667eea" stroke-width="2" rx="8"/>
            <text x="150" y="55" text-anchor="middle" font-size="16" font-weight="bold" fill="#667eea">Original Cloud</text>
            <!-- Random dots (dense) -->
            <circle cx="50" cy="80" r="3" fill="#333"/><circle cx="65" cy="85" r="3" fill="#333"/>
            <circle cx="55" cy="95" r="3" fill="#333"/><circle cx="70" cy="78" r="3" fill="#333"/>
            <circle cx="100" cy="120" r="3" fill="#333"/><circle cx="115" cy="125" r="3" fill="#333"/>
            <circle cx="105" cy="135" r="3" fill="#333"/><circle cx="120" cy="118" r="3" fill="#333"/>
            <circle cx="150" cy="160" r="3" fill="#333"/><circle cx="165" cy="165" r="3" fill="#333"/>
            <circle cx="155" cy="175" r="3" fill="#333"/><circle cx="170" cy="158" r="3" fill="#333"/>
            <circle cx="200" cy="200" r="3" fill="#333"/><circle cx="215" cy="205" r="3" fill="#333"/>
            <circle cx="205" cy="215" r="3" fill="#333"/><circle cx="220" cy="198" r="3" fill="#333"/>
            <circle cx="80" cy="180" r="3" fill="#333"/><circle cx="90" cy="190" r="3" fill="#333"/>
            <circle cx="85" cy="200" r="3" fill="#333"/><circle cx="95" cy="178" r="3" fill="#333"/>
            <circle cx="180" cy="100" r="3" fill="#333"/><circle cx="195" cy="105" r="3" fill="#333"/>
            <circle cx="185" cy="115" r="3" fill="#333"/><circle cx="200" cy="98" r="3" fill="#333"/>
            <circle cx="230" cy="140" r="3" fill="#333"/><circle cx="245" cy="145" r="3" fill="#333"/>
            <circle cx="235" cy="155" r="3" fill="#333"/><circle cx="250" cy="138" r="3" fill="#333"/>
            <text x="150" y="248" text-anchor="middle" font-size="14" fill="#666">32,790 points</text>

            <!-- Arrow -->
            <text x="320" y="140" font-size="40" fill="#764ba2">&#x27A1;</text>
            <text x="330" y="170" text-anchor="middle" font-size="12" fill="#764ba2">Voxel Grid</text>

            <!-- Downsampled cloud -->
            <rect x="370" y="20" width="260" height="240" fill="#f0fff0" stroke="#4CAF50" stroke-width="2" rx="8"/>
            <text x="500" y="55" text-anchor="middle" font-size="16" font-weight="bold" fill="#4CAF50">Downsampled</text>
            <!-- Grid lines -->
            <line x1="370" y1="100" x2="630" y2="100" stroke="#ddd" stroke-dasharray="4"/>
            <line x1="370" y1="160" x2="630" y2="160" stroke="#ddd" stroke-dasharray="4"/>
            <line x1="370" y1="220" x2="630" y2="220" stroke="#ddd" stroke-dasharray="4"/>
            <line x1="455" y1="60" x2="455" y2="260" stroke="#ddd" stroke-dasharray="4"/>
            <line x1="545" y1="60" x2="545" y2="260" stroke="#ddd" stroke-dasharray="4"/>
            <!-- Centroids -->
            <circle cx="415" cy="85" r="5" fill="#4CAF50"/>
            <circle cx="500" cy="85" r="5" fill="#4CAF50"/>
            <circle cx="585" cy="85" r="5" fill="#4CAF50"/>
            <circle cx="415" cy="135" r="5" fill="#4CAF50"/>
            <circle cx="500" cy="135" r="5" fill="#4CAF50"/>
            <circle cx="585" cy="135" r="5" fill="#4CAF50"/>
            <circle cx="415" cy="195" r="5" fill="#4CAF50"/>
            <circle cx="500" cy="195" r="5" fill="#4CAF50"/>
            <circle cx="585" cy="195" r="5" fill="#4CAF50"/>
            <text x="500" y="248" text-anchor="middle" font-size="14" fill="#666">5,800 points (17.7%)</text>
        </svg>
        <p class="image-caption">Voxel grid downsampling divides 3D space into cubes and replaces all points in each voxel with their centroid</p>
    </div>

    <h4>Algorithm:</h4>
    <div class="diagram">
        <div class="flow-step">1. Compute bounding box of point cloud P</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">2. Divide bounding box into voxels of size v</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">3. For each occupied voxel: compute centroid of all points inside</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">4. Output: one centroid point per occupied voxel</div>
    </div>

    <div class="math">\[ \text{Complexity: } O(N) \text{ where } N = \text{number of points} \]</div>

    <h4>Voxel Size Trade-offs:</h4>
    <table>
        <tr>
            <th>Voxel Size</th>
            <th>Points Remaining</th>
            <th>Reduction</th>
            <th>Best For</th>
        </tr>
        <tr>
            <td>0.01m</td>
            <td>~99%</td>
            <td>Minimal</td>
            <td>High-detail inspection</td>
        </tr>
        <tr>
            <td>0.05m</td>
            <td>~60%</td>
            <td>Moderate</td>
            <td>Obstacle detection (recommended)</td>
        </tr>
        <tr>
            <td>0.10m</td>
            <td>~30%</td>
            <td>Significant</td>
            <td>Fast prototyping</td>
        </tr>
        <tr>
            <td>0.50m</td>
            <td>~5%</td>
            <td>Aggressive</td>
            <td>Coarse mapping</td>
        </tr>
    </table>

    <div class="tip">
        For autonomous driving obstacle detection, 0.05m&ndash;0.1m voxel size provides a good balance between speed and accuracy.
    </div>
</div>

<!-- PAGE 4: RANSAC GROUND SEGMENTATION -->
<div class="page">
    <h2>Part 2: RANSAC Ground Segmentation (60 minutes)</h2>

    <h3>The RANSAC Algorithm</h3>
    <p><strong>RANSAC</strong> (Random Sample Consensus) is a robust model fitting algorithm that handles outliers. For ground plane extraction, we fit a plane to the largest flat surface in the point cloud.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1558618666-fcd25c85f82e?w=800" alt="Ground Plane">
        <p class="image-caption">RANSAC separates ground points (green) from obstacle points (red) by fitting a plane model</p>
    </div>

    <div class="info-box">
        <h4>Plane Equation</h4>
        <div class="math">\[ ax + by + cz + d = 0 \]</div>
        <p>Where \((a, b, c)\) is the plane normal vector and \(d\) is the offset from origin.</p>
    </div>

    <h4>Algorithm Steps:</h4>
    <div class="diagram">
        <div class="flow-step">1. Randomly select 3 points (minimum for a plane)</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">2. Fit a plane through these 3 points using cross product</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">3. Count inliers: points within distance threshold t of the plane</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">4. Repeat N iterations, keep the plane with the most inliers</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">5. Final: refit plane using all best inliers (least squares)</div>
    </div>

    <h3>Mathematical Derivation</h3>

    <div class="info-box">
        <h4>Fitting a Plane from 3 Points \((p_1, p_2, p_3)\)</h4>
        <div class="math">\[
            \vec{v}_1 = p_2 - p_1 \qquad
            \vec{v}_2 = p_3 - p_1
        \] \[
            \mathbf{normal} = \vec{v}_1 \times \vec{v}_2 = (a, b, c)
        \] \[
            d = -(a \cdot p_1.x + b \cdot p_1.y + c \cdot p_1.z)
        \]</div>
    </div>

    <div class="info-box">
        <h4>Distance from Point q to Plane</h4>
        <div class="math">\[
            \text{dist}(q) = \frac{|a \cdot q_x + b \cdot q_y + c \cdot q_z + d|}{\sqrt{a^2 + b^2 + c^2}}
        \]</div>
    </div>

    <h3>Choosing RANSAC Parameters</h3>

    <div class="info-box">
        <h4>Number of Iterations Formula</h4>
        <div class="math">\[ N = \frac{\log(1 - p)}{\log(1 - w^n)} \]</div>
        <ul>
            <li>\(p\) = desired probability of success (e.g., 0.99)</li>
            <li>\(w\) = fraction of inliers in data</li>
            <li>\(n\) = minimum points for model (3 for plane)</li>
        </ul>
    </div>

    <div class="example-box">
        <h4>Example Calculation:</h4>
        <p>If 60% of points are ground (\(w = 0.6\)), \(n = 3\), \(p = 0.99\):</p>
        <div class="math">\[ N = \frac{\log(1 - 0.99)}{\log(1 - 0.6^3)} = \frac{\log(0.01)}{\log(0.784)} \approx \mathbf{19 \text{ iterations}} \]</div>
        <p>In practice, use 100&ndash;1000 iterations for robustness.</p>
    </div>

    <h4>Distance Threshold Trade-offs:</h4>
    <table>
        <tr>
            <th>Threshold</th>
            <th>Effect</th>
            <th>Risk</th>
        </tr>
        <tr>
            <td>0.05m (too small)</td>
            <td>Tight fit, few inliers</td>
            <td>Misses ground on uneven terrain</td>
        </tr>
        <tr>
            <td>0.15m (typical)</td>
            <td>Good balance</td>
            <td>Works well for flat surfaces</td>
        </tr>
        <tr>
            <td>0.50m (too large)</td>
            <td>Many inliers</td>
            <td>Includes low obstacles as "ground"</td>
        </tr>
    </table>
</div>

<!-- PAGE 5: KD-TREES -->
<div class="page">
    <h3>Spatial Indexing with KD-Trees</h3>

    <p>Clustering requires finding nearby points efficiently. A brute-force approach checks every pair &mdash; \(O(N^2)\). KD-Trees reduce this dramatically.</p>

    <div class="info-box">
        <h4>What is a KD-Tree?</h4>
        <p>A <strong>KD-Tree</strong> (K-Dimensional Tree) is a binary space-partitioning tree for organizing points in k-dimensional space. It alternates splitting axes at each level.</p>
    </div>

    <div class="image-container">
        <svg width="650" height="320" style="max-width: 100%;">
            <!-- 2D space partition -->
            <rect x="20" y="20" width="280" height="280" fill="#f8f8ff" stroke="#667eea" stroke-width="2" rx="5"/>
            <text x="160" y="15" text-anchor="middle" font-size="14" font-weight="bold" fill="#667eea">2D Space Partition</text>

            <!-- Vertical split -->
            <line x1="160" y1="20" x2="160" y2="300" stroke="#c62828" stroke-width="2"/>
            <!-- Horizontal splits -->
            <line x1="20" y1="170" x2="160" y2="170" stroke="#2e7d32" stroke-width="2"/>
            <line x1="160" y1="130" x2="300" y2="130" stroke="#2e7d32" stroke-width="2"/>

            <!-- Points -->
            <circle cx="80" cy="100" r="6" fill="#667eea"/><text x="80" y="90" text-anchor="middle" font-size="11" fill="#333">A</text>
            <circle cx="120" cy="220" r="6" fill="#764ba2"/><text x="120" y="210" text-anchor="middle" font-size="11" fill="#333">B</text>
            <circle cx="200" cy="80" r="6" fill="#4CAF50"/><text x="200" y="70" text-anchor="middle" font-size="11" fill="#333">C</text>
            <circle cx="250" cy="200" r="6" fill="#ff9800"/><text x="250" y="190" text-anchor="middle" font-size="11" fill="#333">D</text>
            <circle cx="60" cy="260" r="6" fill="#9c27b0"/><text x="60" y="250" text-anchor="middle" font-size="11" fill="#333">E</text>

            <!-- Tree structure -->
            <text x="490" y="15" text-anchor="middle" font-size="14" font-weight="bold" fill="#667eea">Tree Structure</text>
            <rect x="450" y="30" width="80" height="35" fill="#c62828" rx="5"/>
            <text x="490" y="52" text-anchor="middle" fill="white" font-size="12">Root (x)</text>

            <line x1="470" y1="65" x2="420" y2="100" stroke="#333" stroke-width="2"/>
            <line x1="510" y1="65" x2="560" y2="100" stroke="#333" stroke-width="2"/>

            <rect x="380" y="100" width="80" height="35" fill="#2e7d32" rx="5"/>
            <text x="420" y="122" text-anchor="middle" fill="white" font-size="12">Left (y)</text>
            <rect x="520" y="100" width="80" height="35" fill="#2e7d32" rx="5"/>
            <text x="560" y="122" text-anchor="middle" fill="white" font-size="12">Right (y)</text>

            <line x1="400" y1="135" x2="380" y2="170" stroke="#333" stroke-width="1.5"/>
            <line x1="440" y1="135" x2="460" y2="170" stroke="#333" stroke-width="1.5"/>
            <line x1="540" y1="135" x2="520" y2="170" stroke="#333" stroke-width="1.5"/>
            <line x1="580" y1="135" x2="600" y2="170" stroke="#333" stroke-width="1.5"/>

            <circle cx="380" cy="185" r="15" fill="#667eea"/>
            <text x="380" y="190" text-anchor="middle" fill="white" font-size="12">A</text>
            <circle cx="460" cy="185" r="15" fill="#764ba2"/>
            <text x="460" y="190" text-anchor="middle" fill="white" font-size="12">B</text>
            <circle cx="520" cy="185" r="15" fill="#4CAF50"/>
            <text x="520" y="190" text-anchor="middle" fill="white" font-size="12">C</text>
            <circle cx="600" cy="185" r="15" fill="#ff9800"/>
            <text x="600" y="190" text-anchor="middle" fill="white" font-size="12">D</text>
        </svg>
        <p class="image-caption">A KD-Tree recursively partitions space by alternating axes, enabling fast nearest-neighbour queries</p>
    </div>

    <h4>Complexity Comparison:</h4>
    <table>
        <tr>
            <th>Operation</th>
            <th>KD-Tree</th>
            <th>Brute Force</th>
        </tr>
        <tr>
            <td>Build</td>
            <td>\(O(N \log N)\)</td>
            <td>N/A</td>
        </tr>
        <tr>
            <td>Nearest Neighbour</td>
            <td>\(O(\log N)\) average</td>
            <td>\(O(N)\)</td>
        </tr>
        <tr>
            <td>Range Search</td>
            <td>\(O(\sqrt{N} + k)\) average</td>
            <td>\(O(N)\)</td>
        </tr>
        <tr>
            <td>Space</td>
            <td>\(O(N)\)</td>
            <td>\(O(N)\)</td>
        </tr>
    </table>

    <div class="activity-box">
        <h3>Activity 1: KD-Tree Walkthrough (10 minutes)</h3>
        <p><strong>Instructions:</strong> Given the following 2D points, build a KD-Tree by hand:</p>
        <div class="math">\[ \text{Points: } (3,6),\; (17,15),\; (13,15),\; (6,12),\; (9,1),\; (2,7),\; (10,19) \]</div>
        <ol>
            <li>Sort by x-axis, pick median as root</li>
            <li>Split left/right subtrees</li>
            <li>Alternate to y-axis, repeat</li>
            <li>Draw the resulting tree and space partition</li>
        </ol>
        <p><strong>Discussion:</strong> How many comparisons does a nearest-neighbour query take in your tree vs brute force?</p>
    </div>
</div>

<!-- PAGE 6: BREAK -->
<div class="page">
    <div style="display: flex; align-items: center; justify-content: center; min-height: 80vh; text-align: center;">
        <div>
            <h1 style="font-size: 3em; color: #667eea; margin-bottom: 30px;">Break Time</h1>
            <div class="image-container">
                <img src="https://images.unsplash.com/photo-1495474472287-4d71bcdd2085?w=600" alt="Coffee Break" style="max-width: 500px;">
                <p class="image-caption">Take a 15-minute break. Stretch, hydrate, and refresh!</p>
            </div>
            <h2 style="color: #764ba2; margin-top: 40px;">We'll resume with Clustering &amp; Bounding Box Fitting</h2>
            <p style="font-size: 1.5em; margin-top: 20px; color: #666;">Back in 15 minutes</p>
        </div>
    </div>
</div>

<!-- PAGE 7: CLUSTERING -->
<div class="page">
    <h2>Part 3: Clustering &amp; Bounding Box Fitting (60 minutes)</h2>

    <h3>Euclidean Clustering</h3>
    <p>After removing the ground plane, we need to group the remaining obstacle points into individual objects. Euclidean clustering uses a BFS/flood-fill approach with a KD-Tree for efficiency.</p>

    <div class="image-container">
        <svg width="650" height="250" style="max-width: 100%;">
            <!-- Ungrouped points -->
            <rect x="20" y="20" width="260" height="210" fill="#f0f0f0" stroke="#667eea" stroke-width="2" rx="8"/>
            <text x="150" y="50" text-anchor="middle" font-size="14" font-weight="bold" fill="#667eea">Obstacle Points</text>
            <!-- Cluster 1 -->
            <circle cx="70" cy="100" r="4" fill="#333"/><circle cx="80" cy="110" r="4" fill="#333"/>
            <circle cx="75" cy="120" r="4" fill="#333"/><circle cx="90" cy="105" r="4" fill="#333"/>
            <circle cx="85" cy="95" r="4" fill="#333"/>
            <!-- Cluster 2 -->
            <circle cx="180" cy="90" r="4" fill="#333"/><circle cx="190" cy="100" r="4" fill="#333"/>
            <circle cx="185" cy="110" r="4" fill="#333"/><circle cx="200" cy="95" r="4" fill="#333"/>
            <!-- Cluster 3 -->
            <circle cx="130" cy="180" r="4" fill="#333"/><circle cx="140" cy="190" r="4" fill="#333"/>
            <circle cx="135" cy="200" r="4" fill="#333"/><circle cx="150" cy="185" r="4" fill="#333"/>
            <circle cx="145" cy="175" r="4" fill="#333"/><circle cx="155" cy="195" r="4" fill="#333"/>
            <!-- Noise -->
            <circle cx="240" cy="180" r="4" fill="#ccc"/>

            <!-- Arrow -->
            <text x="320" y="125" font-size="40" fill="#764ba2">&#x27A1;</text>
            <text x="330" y="155" text-anchor="middle" font-size="12" fill="#764ba2">Cluster</text>

            <!-- Grouped points -->
            <rect x="370" y="20" width="260" height="210" fill="#f0fff0" stroke="#4CAF50" stroke-width="2" rx="8"/>
            <text x="500" y="50" text-anchor="middle" font-size="14" font-weight="bold" fill="#4CAF50">Clustered Objects</text>
            <!-- Cluster 1 - red -->
            <circle cx="420" cy="100" r="5" fill="#e53935"/><circle cx="430" cy="110" r="5" fill="#e53935"/>
            <circle cx="425" cy="120" r="5" fill="#e53935"/><circle cx="440" cy="105" r="5" fill="#e53935"/>
            <circle cx="435" cy="95" r="5" fill="#e53935"/>
            <text x="430" cy="140" y="140" font-size="11" fill="#e53935" text-anchor="middle">Car 1</text>
            <!-- Cluster 2 - blue -->
            <circle cx="530" cy="90" r="5" fill="#1e88e5"/><circle cx="540" cy="100" r="5" fill="#1e88e5"/>
            <circle cx="535" cy="110" r="5" fill="#1e88e5"/><circle cx="550" cy="95" r="5" fill="#1e88e5"/>
            <text x="540" y="130" font-size="11" fill="#1e88e5" text-anchor="middle">Pedestrian</text>
            <!-- Cluster 3 - green -->
            <circle cx="480" cy="180" r="5" fill="#43a047"/><circle cx="490" cy="190" r="5" fill="#43a047"/>
            <circle cx="485" cy="200" r="5" fill="#43a047"/><circle cx="500" cy="185" r="5" fill="#43a047"/>
            <circle cx="495" cy="175" r="5" fill="#43a047"/><circle cx="505" cy="195" r="5" fill="#43a047"/>
            <text x="493" y="215" font-size="11" fill="#43a047" text-anchor="middle">Truck</text>
        </svg>
        <p class="image-caption">Euclidean clustering groups nearby points into distinct objects</p>
    </div>

    <h4>Algorithm (BFS with KD-Tree):</h4>
    <pre>
<span class="keyword">Input:</span> Points P, distance threshold d, min_size, max_size
1. Build KD-Tree from P
2. Create visited set (all False)
3. clusters = []
4. <span class="keyword">For each</span> unvisited point p:
   a. queue = [p], mark p visited
   b. cluster = []
   c. <span class="keyword">While</span> queue not empty:
      - q = queue.pop()
      - cluster.append(q)
      - neighbours = kdtree.radius_search(q, d)
      - <span class="keyword">For each</span> unvisited neighbour n:
        mark n visited, queue.append(n)
   d. <span class="keyword">If</span> min_size &le; |cluster| &le; max_size:
      clusters.append(cluster)
<span class="keyword">Output:</span> List of clusters
    </pre>

    <h4>Clustering Parameters:</h4>
    <table>
        <tr>
            <th>Parameter</th>
            <th>Typical Range</th>
            <th>Effect</th>
        </tr>
        <tr>
            <td><strong>d</strong> (distance threshold)</td>
            <td>0.3m &ndash; 1.0m</td>
            <td>Too small: over-segments; Too large: merges objects</td>
        </tr>
        <tr>
            <td><strong>min_size</strong></td>
            <td>10 &ndash; 50 points</td>
            <td>Filters small noise clusters</td>
        </tr>
        <tr>
            <td><strong>max_size</strong></td>
            <td>5000 &ndash; 25000</td>
            <td>Filters oversized merged clusters</td>
        </tr>
    </table>

    <h3>DBSCAN vs Euclidean Clustering</h3>
    <div class="two-column">
        <div class="info-box">
            <h4>Euclidean Clustering</h4>
            <ul>
                <li>Only uses distance threshold</li>
                <li>Simpler, faster</li>
                <li>All points assigned to clusters</li>
                <li>Preferred when speed matters</li>
            </ul>
        </div>
        <div class="info-box">
            <h4>DBSCAN</h4>
            <ul>
                <li>Adds min_pts density requirement</li>
                <li>Distinguishes core/border/noise</li>
                <li>Better noise rejection</li>
                <li>Finds arbitrary-shape clusters</li>
            </ul>
        </div>
    </div>
</div>

<!-- PAGE 8: BOUNDING BOXES -->
<div class="page">
    <h3>Bounding Box Fitting</h3>

    <p>After clustering, we need to enclose each detected object with a bounding box for tracking, classification, and collision avoidance.</p>

    <h4>Axis-Aligned Bounding Box (AABB)</h4>
    <div class="info-box">
        <p>Simplest approach &mdash; box edges aligned with coordinate axes:</p>
        <pre>
min_point = np.min(cluster_points, axis=0)  # (x_min, y_min, z_min)
max_point = np.max(cluster_points, axis=0)  # (x_max, y_max, z_max)
center    = (min_point + max_point) / 2
size      = max_point - min_point
volume    = size[0] * size[1] * size[2]
        </pre>
        <p><strong>Limitation:</strong> Overestimates volume for rotated objects.</p>
    </div>

    <h4>Oriented Bounding Box (OBB) using PCA</h4>
    <div class="info-box">
        <p><strong>Principal Component Analysis</strong> finds the natural axes of the point distribution for a tighter fit:</p>
    </div>

    <div class="diagram">
        <div class="flow-step">1. Compute centroid: \(\mu = \text{mean}(\text{points})\)</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">2. Centre points: \(P_{\text{centred}} = P - \mu\)</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">3. Covariance matrix: \(C = \frac{1}{N} P_{\text{centred}}^T \cdot P_{\text{centred}}\)</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">4. Eigendecomposition: \(C = V \cdot \Lambda \cdot V^T\)</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">5. \(V\) columns = principal axes (orientation of OBB)</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">6. Transform points to principal frame, compute AABB there, transform back</div>
    </div>

    <h3>Intersection over Union (IoU)</h3>
    <p>Used to evaluate detection quality against ground truth:</p>

    <div class="image-container">
        <svg width="500" height="200" style="max-width: 100%;">
            <!-- Detection box -->
            <rect x="80" y="30" width="200" height="140" fill="rgba(102,126,234,0.3)" stroke="#667eea" stroke-width="3" rx="5"/>
            <text x="280" y="50" font-size="13" fill="#667eea" font-weight="bold">Detection</text>
            <!-- GT box -->
            <rect x="140" y="50" width="200" height="140" fill="rgba(76,175,80,0.3)" stroke="#4CAF50" stroke-width="3" rx="5"/>
            <text x="340" y="195" font-size="13" fill="#4CAF50" font-weight="bold">Ground Truth</text>
            <!-- Intersection -->
            <rect x="140" y="50" width="140" height="120" fill="rgba(255,152,0,0.4)" stroke="#ff9800" stroke-width="2" stroke-dasharray="5"/>
            <text x="210" y="115" text-anchor="middle" font-size="14" fill="#ff9800" font-weight="bold">Intersection</text>
        </svg>
    </div>

    <div class="math">\[ \text{IoU} = \frac{\text{Volume(Intersection)}}{\text{Volume(Union)}} \]</div>

    <table>
        <tr>
            <th>IoU Range</th>
            <th>Quality</th>
            <th>Interpretation</th>
        </tr>
        <tr>
            <td>&gt; 0.7</td>
            <td style="color: #2e7d32; font-weight: bold;">Good</td>
            <td>Strong detection, well-aligned</td>
        </tr>
        <tr>
            <td>0.5 &ndash; 0.7</td>
            <td style="color: #ff9800; font-weight: bold;">Acceptable</td>
            <td>Reasonable match, some misalignment</td>
        </tr>
        <tr>
            <td>&lt; 0.3</td>
            <td style="color: #c62828; font-weight: bold;">Poor</td>
            <td>Detection does not match ground truth</td>
        </tr>
    </table>

    <div class="activity-box">
        <h3>Activity 2: IoU Calculation (10 minutes)</h3>
        <p><strong>Task:</strong> Given two 3D axis-aligned boxes, compute the IoU by hand:</p>
        <div class="math">\[
            \text{Box A: } \min = (0,0,0), \; \max = (4,3,2)
        \] \[
            \text{Box B: } \min = (2,1,1), \; \max = (6,5,3)
        \]</div>
        <ol>
            <li>Find the intersection box min and max corners</li>
            <li>Compute intersection volume</li>
            <li>Compute union volume</li>
            <li>Calculate IoU</li>
        </ol>
    </div>
</div>

<!-- PAGE 9: COMPLETE PIPELINE -->
<div class="page">
    <h2>Part 4: Full Pipeline Integration (60 minutes)</h2>

    <h3>Complete LiDAR Obstacle Detection Pipeline</h3>

    <div class="diagram">
        <h4 style="text-align: center; color: #667eea;">End-to-End Processing Pipeline</h4>
        <svg width="600" height="500" style="max-width: 100%;">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="5" refY="5" orient="auto">
                    <polygon points="0 0, 10 5, 0 10" fill="#764ba2" />
                </marker>
            </defs>

            <!-- Step 1 -->
            <rect x="150" y="10" width="300" height="50" fill="#667eea" rx="10"/>
            <text x="300" y="40" text-anchor="middle" fill="white" font-size="15" font-weight="bold">1. Raw Point Cloud (32,790 pts)</text>
            <line x1="300" y1="60" x2="300" y2="80" stroke="#764ba2" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Step 2 -->
            <rect x="150" y="85" width="300" height="50" fill="#764ba2" rx="10"/>
            <text x="300" y="115" text-anchor="middle" fill="white" font-size="15" font-weight="bold">2. Voxel Downsampling (20,624 pts)</text>
            <line x1="300" y1="135" x2="300" y2="155" stroke="#764ba2" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Step 3 -->
            <rect x="150" y="160" width="300" height="50" fill="#4CAF50" rx="10"/>
            <text x="300" y="190" text-anchor="middle" fill="white" font-size="15" font-weight="bold">3. RANSAC Ground Removal</text>
            <line x1="300" y1="210" x2="300" y2="230" stroke="#764ba2" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Split -->
            <rect x="50" y="235" width="180" height="40" fill="#2e7d32" rx="8"/>
            <text x="140" y="260" text-anchor="middle" fill="white" font-size="13">Ground (19,401 pts)</text>
            <rect x="370" y="235" width="180" height="40" fill="#c62828" rx="8"/>
            <text x="460" y="260" text-anchor="middle" fill="white" font-size="13">Obstacles (1,223 pts)</text>

            <line x1="200" y1="220" x2="140" y2="235" stroke="#2e7d32" stroke-width="2"/>
            <line x1="400" y1="220" x2="460" y2="235" stroke="#c62828" stroke-width="2"/>
            <line x1="460" y1="275" x2="300" y2="300" stroke="#764ba2" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Step 4 -->
            <rect x="150" y="305" width="300" height="50" fill="#ff9800" rx="10"/>
            <text x="300" y="335" text-anchor="middle" fill="white" font-size="15" font-weight="bold">4. Euclidean Clustering (5 objects)</text>
            <line x1="300" y1="355" x2="300" y2="375" stroke="#764ba2" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Step 5 -->
            <rect x="150" y="380" width="300" height="50" fill="#9c27b0" rx="10"/>
            <text x="300" y="410" text-anchor="middle" fill="white" font-size="15" font-weight="bold">5. Bounding Box Fitting</text>
            <line x1="300" y1="430" x2="300" y2="450" stroke="#764ba2" stroke-width="3" marker-end="url(#arrowhead)"/>

            <!-- Output -->
            <rect x="100" y="455" width="400" height="40" fill="#333" rx="10"/>
            <text x="300" y="480" text-anchor="middle" fill="white" font-size="14" font-weight="bold">Detected Obstacles (Precision: 100%, Recall: 100%, IoU: 0.79)</text>
        </svg>
    </div>

    <h3>Real-Time Performance Budget</h3>
    <p>For autonomous driving, the pipeline must run at <strong>10Hz</strong> (100ms per frame):</p>

    <table>
        <tr>
            <th>Stage</th>
            <th>Typical Time</th>
            <th>Optimization</th>
        </tr>
        <tr>
            <td>Voxel downsample</td>
            <td>5&ndash;10ms</td>
            <td>GPU acceleration (CUDA)</td>
        </tr>
        <tr>
            <td>RANSAC</td>
            <td>10&ndash;20ms</td>
            <td>Early termination</td>
        </tr>
        <tr>
            <td>KD-Tree build</td>
            <td>10&ndash;15ms</td>
            <td>Incremental update</td>
        </tr>
        <tr>
            <td>Clustering</td>
            <td>15&ndash;30ms</td>
            <td>Parallel BFS</td>
        </tr>
        <tr>
            <td>Bounding boxes</td>
            <td>2&ndash;5ms</td>
            <td>Minimal overhead</td>
        </tr>
        <tr style="font-weight: bold; background: #e8f4f8;">
            <td>Total</td>
            <td>42&ndash;80ms</td>
            <td>Fits in 100ms budget</td>
        </tr>
    </table>
</div>

<!-- PAGE 10: LAB OVERVIEW -->
<div class="page">
    <h2>Part 5: Hands-On Lab (105 minutes)</h2>

    <h3>Lab Setup</h3>
    <div class="info-box">
        <h4>Environment Setup</h4>
        <pre>
cd ~/auto_ws/src/ros2_robotics_course/week_01/lab_exercises
pip install open3d numpy matplotlib scipy
python3 generate_sample_data.py   # generates sample point clouds
        </pre>
    </div>

    <h3>Lab Tasks Overview</h3>
    <table>
        <tr>
            <th>Task</th>
            <th>File</th>
            <th>Key Algorithm</th>
            <th>Expected Output</th>
        </tr>
        <tr>
            <td><strong>1</strong></td>
            <td>task1_load_and_visualize.py</td>
            <td>PCD parsing, 3D plotting</td>
            <td>32,790 points loaded, statistics printed</td>
        </tr>
        <tr>
            <td><strong>2</strong></td>
            <td>task2_voxel_downsampling.py</td>
            <td>Voxel grid filtering</td>
            <td>Reduction to 5,800 pts at v=0.5m</td>
        </tr>
        <tr>
            <td><strong>3</strong></td>
            <td>task3_ransac_ground_removal.py</td>
            <td>RANSAC plane fitting</td>
            <td>~30K ground, ~2K obstacle points</td>
        </tr>
        <tr>
            <td><strong>4</strong></td>
            <td>task4_euclidean_clustering.py</td>
            <td>BFS + KD-Tree clustering</td>
            <td>5 clusters detected</td>
        </tr>
        <tr>
            <td><strong>5</strong></td>
            <td>task5_bounding_boxes.py</td>
            <td>AABB, OBB via PCA, IoU</td>
            <td>Bounding boxes with IoU scores</td>
        </tr>
        <tr>
            <td><strong>6</strong></td>
            <td>task6_full_pipeline.py</td>
            <td>End-to-end integration</td>
            <td>100% precision, 100% recall, IoU 0.79</td>
        </tr>
    </table>

    <div class="activity-box">
        <h3>Lab Activity: Complete Pipeline Implementation</h3>
        <p><strong>Instructions:</strong></p>
        <ol>
            <li>Open each task file &mdash; read the function stubs and docstrings carefully</li>
            <li>Implement each function following the algorithm descriptions from the lecture</li>
            <li>Run each task to verify your implementation against expected outputs</li>
            <li>Complete Task 6 to integrate everything into a full pipeline</li>
            <li>Compare your pipeline output with the ground truth data</li>
        </ol>
        <p><strong>Evaluation Criteria:</strong></p>
        <table>
            <tr><th>Criteria</th><th>Weight</th></tr>
            <tr><td>Algorithm correctness</td><td>30%</td></tr>
            <tr><td>Code quality and efficiency</td><td>25%</td></tr>
            <tr><td>Handling of edge cases</td><td>20%</td></tr>
            <tr><td>Documentation</td><td>15%</td></tr>
            <tr><td>Visualization quality</td><td>10%</td></tr>
        </table>
    </div>

    <div class="tip">
        Start with Task 1 and work sequentially. Each task builds on the previous one. If stuck, review the lecture notes for the corresponding algorithm.
    </div>
</div>

<!-- PAGE 11: INTERVIEW PREPARATION -->
<div class="page">
    <h2>Interview Preparation</h2>

    <h3>Technical Interview Questions</h3>
    <p>These questions are commonly asked in perception engineer interviews at autonomous vehicle and drone companies:</p>

    <div class="info-box">
        <h4>Q1: Explain RANSAC and its time complexity. How do you choose the number of iterations?</h4>
        <p><strong>Key Points:</strong></p>
        <ul>
            <li>RANSAC iteratively fits a model to random subsets, then counts inliers</li>
            <li>Time: \(O(N \times k)\) where \(k\) = iterations, \(N\) = points for distance check</li>
            <li>Iterations: \(N = \frac{\log(1-p)}{\log(1-w^n)}\)</li>
            <li>Trade-off: more iterations = higher confidence but slower</li>
        </ul>
    </div>

    <div class="info-box">
        <h4>Q2: Why use KD-Tree for clustering? What's the time complexity vs brute force?</h4>
        <p><strong>Key Points:</strong></p>
        <ul>
            <li>KD-Tree: \(O(\log N)\) average for nearest neighbour vs \(O(N)\) brute force</li>
            <li>Radius search: \(O(\sqrt{N} + k)\) vs \(O(N)\)</li>
            <li>Critical for real-time clustering of large point clouds (100K+ points)</li>
        </ul>
    </div>

    <div class="info-box">
        <h4>Q3: How do you handle dynamic objects vs static obstacles?</h4>
        <p><strong>Key Points:</strong></p>
        <ul>
            <li>Multi-frame tracking: associate clusters across consecutive frames</li>
            <li>Velocity estimation via centroid displacement between frames</li>
            <li>Static objects: consistent position across frames</li>
            <li>Dynamic objects: use motion prediction for collision avoidance</li>
        </ul>
    </div>

    <div class="info-box">
        <h4>Q4: Describe the difference between Euclidean clustering and DBSCAN.</h4>
        <p><strong>Key Points:</strong></p>
        <ul>
            <li>Euclidean: only distance threshold, simpler, faster</li>
            <li>DBSCAN: adds min_pts requirement, better noise rejection</li>
            <li>DBSCAN distinguishes core/border/noise points</li>
            <li>Euclidean preferred when speed matters; DBSCAN when noise is high</li>
        </ul>
    </div>

    <div class="info-box">
        <h4>Q5: How would you optimise this pipeline for real-time performance (10Hz)?</h4>
        <p><strong>Key Points:</strong></p>
        <ul>
            <li>Voxel downsampling to reduce point count</li>
            <li>GPU-accelerated RANSAC (CUDA)</li>
            <li>Incremental KD-Tree updates between frames</li>
            <li>Parallel clustering with thread pool</li>
            <li>ROI cropping to limit search space</li>
        </ul>
    </div>

    <div class="activity-box">
        <h3>Activity 3: Mock Interview (15 minutes)</h3>
        <p><strong>Instructions:</strong> Work in pairs. One person acts as the interviewer, the other as the candidate.</p>
        <ol>
            <li>The interviewer picks 2 questions from above</li>
            <li>The candidate answers without notes (3 minutes per question)</li>
            <li>The interviewer provides feedback on clarity and completeness</li>
            <li>Switch roles and repeat</li>
        </ol>
    </div>
</div>

<!-- PAGE 12: REFERENCES AND RESOURCES -->
<div class="page">
    <h2>References &amp; Resources</h2>

    <h3>GitHub Repositories</h3>
    <div class="info-box">
        <ul>
            <li><strong>knaaga/lidar-obstacle-detection</strong> &mdash; C++ pipeline with PCL (Waymo style)</li>
            <li><strong>arief25ramadhan/point-cloud-processing</strong> &mdash; Python pipeline with Open3D</li>
        </ul>
    </div>

    <h3>Libraries &amp; Tools</h3>
    <table>
        <tr>
            <th>Library</th>
            <th>Language</th>
            <th>Install</th>
            <th>Use Case</th>
        </tr>
        <tr>
            <td><strong>Open3D</strong></td>
            <td>Python/C++</td>
            <td><code>pip install open3d</code></td>
            <td>Modern point cloud processing</td>
        </tr>
        <tr>
            <td><strong>PCL</strong></td>
            <td>C++</td>
            <td><code>sudo apt install libpcl-dev</code></td>
            <td>Industry standard (production)</td>
        </tr>
        <tr>
            <td><strong>NumPy</strong></td>
            <td>Python</td>
            <td><code>pip install numpy</code></td>
            <td>Array operations, linear algebra</td>
        </tr>
        <tr>
            <td><strong>SciPy</strong></td>
            <td>Python</td>
            <td><code>pip install scipy</code></td>
            <td>KD-Tree, spatial algorithms</td>
        </tr>
        <tr>
            <td><strong>Matplotlib</strong></td>
            <td>Python</td>
            <td><code>pip install matplotlib</code></td>
            <td>3D visualisation</td>
        </tr>
    </table>

    <h3>Key Papers</h3>
    <div class="example-box">
        <p><strong>[1]</strong> M. Fischler and R. Bolles, "Random Sample Consensus: A Paradigm for Model Fitting with Applications to Image Analysis and Automated Cartography," <em>Communications of the ACM</em>, vol. 24, no. 6, pp. 381&ndash;395, 1981.</p>
        <p style="margin-top: 10px;"><strong>[2]</strong> M. Ester, H.-P. Kriegel, J. Sander, and X. Xu, "A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise," in <em>Proc. KDD</em>, 1996, pp. 226&ndash;231.</p>
        <p style="margin-top: 10px;"><strong>[3]</strong> J. Bentley, "Multidimensional Binary Search Trees Used for Associative Searching," <em>Communications of the ACM</em>, vol. 18, no. 9, pp. 509&ndash;517, 1975.</p>
    </div>

    <h3>Lab Equipment</h3>
    <div class="info-box">
        <ul>
            <li><strong>RPLiDAR S2:</strong> 2D LiDAR, 30m range, 32K points/sec</li>
            <li><strong>ROS2 Driver:</strong> <code>ros2 launch rplidar_ros rplidar_s2_launch.py</code></li>
        </ul>
    </div>

    <h3>Submission Requirements</h3>
    <div class="checklist">
        <ul>
            <li>All 6 task files completed and running</li>
            <li>Brief report answering: What voxel size did you choose and why?</li>
            <li>Report: How many RANSAC iterations are needed for 99% confidence?</li>
            <li>Report: What clustering parameters worked best?</li>
            <li>Visualisation screenshots showing pipeline output</li>
            <li>Answers to 5 interview questions (in comments or separate file)</li>
        </ul>
    </div>

    <div class="footer">
        <p><strong>Robotics &amp; Drone Engineering</strong></p>
        <p>Open Robotics Course</p>
        <p>Dr. Abdul Manan Khan | Week 1: LiDAR Point Cloud Processing Fundamentals</p>
    </div>
</div>

</body>
</html>
