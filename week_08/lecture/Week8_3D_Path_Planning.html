<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Week 8: 3D Path Planning for Drones - TC70045E</title>
<script>
    MathJax = {
        tex: { inlineMath: [['\\(', '\\)']], displayMath: [['\\[', '\\]']] },
        svg: { fontCache: 'global' }
    };
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
<style>
@page { size: A4; margin: 2cm; }
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; }
.page { width: 21cm; min-height: 29.7cm; padding: 2cm; margin: 20px auto; background: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); page-break-after: always; }
.header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center; border-radius: 10px; margin-bottom: 30px; }
.header h1 { font-size: 2.5em; margin-bottom: 10px; }
.header p { font-size: 1.2em; opacity: 0.9; }
h2 { color: #667eea; border-bottom: 3px solid #764ba2; padding-bottom: 10px; margin: 30px 0 20px 0; font-size: 1.8em; }
h3 { color: #764ba2; margin: 25px 0 15px 0; font-size: 1.4em; }
h4 { color: #667eea; margin: 20px 0 10px 0; font-size: 1.2em; }
.info-box { background: #e8f4f8; border-left: 5px solid #667eea; padding: 20px; margin: 20px 0; border-radius: 5px; }
.warning-box { background: #fff4e6; border-left: 5px solid #ff9800; padding: 20px; margin: 20px 0; border-radius: 5px; }
.activity-box { background: #f0f8ff; border: 3px solid #4CAF50; padding: 25px; margin: 30px 0; border-radius: 10px; }
.activity-box h3 { color: #4CAF50; margin-top: 0; }
.image-container { text-align: center; margin: 30px 0; }
.image-container img { max-width: 100%; height: auto; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
.image-caption { font-style: italic; color: #666; margin-top: 10px; font-size: 0.9em; }
ul, ol { margin: 15px 0 15px 30px; }
li { margin: 8px 0; }
.two-column { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
.two-column > * { min-width: 0; overflow: hidden; }
.three-column { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin: 20px 0; }
.three-column > * { min-width: 0; overflow: hidden; }
.checklist { background: #f9f9f9; padding: 20px; border-radius: 8px; margin: 20px 0; }
.checklist li { list-style: none; padding: 8px 0; }
.checklist li:before { content: "\2713 "; color: #4CAF50; font-weight: bold; margin-right: 10px; }
table { width: 100%; border-collapse: collapse; margin: 20px 0; table-layout: fixed; word-wrap: break-word; }
th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
th { background: #667eea; color: white; }
tr:nth-child(even) { background: #f9f9f9; }
td code { word-break: break-all; }
.diagram { border: 2px solid #667eea; border-radius: 10px; padding: 20px; margin: 20px 0; background: white; }
.flow-step { background: #667eea; color: white; padding: 15px; margin: 10px 0; border-radius: 8px; text-align: center; font-weight: bold; }
.arrow { text-align: center; font-size: 2em; color: #764ba2; margin: 5px 0; }
.tip { background: #fffbea; border-left: 5px solid #ffd700; padding: 15px; margin: 15px 0; border-radius: 5px; }
.tip:before { content: "\1F4A1 TIP: "; font-weight: bold; color: #ff9800; }
code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; word-break: break-all; }
pre { background: #1e1e1e; color: #d4d4d4; padding: 20px; border-radius: 8px; overflow-x: auto; max-width: 100%; white-space: pre-wrap; word-wrap: break-word; margin: 15px 0; font-family: 'Courier New', monospace; font-size: 0.9em; line-height: 1.5; }
.example-box { background: #f0fff0; border: 2px dashed #4CAF50; padding: 20px; margin: 20px 0; border-radius: 8px; }
.math { padding: 15px; margin: 15px 0; border-radius: 5px; overflow-x: auto; max-width: 100%; }
.sensor-card { background: white; border: 2px solid #667eea; border-radius: 10px; padding: 20px; text-align: center; }
.sensor-card h4 { color: #667eea; margin-bottom: 10px; }
img { max-width: 100%; height: auto; }
svg { max-width: 100%; height: auto; }
</style>
</head>
<body>

<!-- ==================== PAGE 1: TITLE ==================== -->
<div class="page">
    <div class="header">
        <h1>3D Path Planning for Drones</h1>
        <p>TC70045E - Robotics &amp; Drone Engineering M.Sc.</p>
        <p>Week 8 Lecture</p>
        <p>Dr. Abdul Manan Khan | University of West London</p>
    </div>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1527977966376-1c8408f9f108?w=900&h=500&fit=crop" alt="Drone navigating through urban obstacles">
        <div class="image-caption">Figure 1.1: Autonomous drone navigating complex 3D environments requires sophisticated path planning algorithms</div>
    </div>

    <div class="info-box">
        <h3>Lecture Overview</h3>
        <p>This week we transition from 2D planning to full <strong>3D path planning</strong> for drones. We cover environment representations (voxels, octrees), graph-based planners (3D A*), sampling-based planners (RRT, RRT*, PRM), trajectory optimization (minimum snap), dynamic replanning, energy-aware planning, geofencing, and ROS 2 integration.</p>
    </div>

    <div class="two-column">
        <div class="sensor-card">
            <h4>Core Algorithms</h4>
            <p>3D A*, RRT, RRT*, Informed RRT*, BIT*, PRM, D* Lite, Minimum Snap Trajectories</p>
        </div>
        <div class="sensor-card">
            <h4>Key Tools</h4>
            <p>OctoMap, ROS 2 Nav2, MoveIt 2, FCL, OMPL, Custom Planner Plugins</p>
        </div>
    </div>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1473968512647-3e447244af8f?w=900&h=350&fit=crop" alt="Drone flying over landscape">
        <div class="image-caption">Figure 1.2: Drones operate in complex 3D airspace with altitude constraints, no-fly zones, and dynamic obstacles</div>
    </div>
</div>

<!-- ==================== PAGE 2: LEARNING OBJECTIVES ==================== -->
<div class="page">
    <h2>Learning Objectives &amp; Why 3D Planning</h2>

    <ul class="checklist">
        <li>Understand 3D environment representations: voxel grids, octrees, point clouds, and meshes</li>
        <li>Implement graph-based 3D planning algorithms (A*, Dijkstra) on 26-connected grids</li>
        <li>Apply sampling-based planners (RRT, RRT*, PRM) to drone path planning</li>
        <li>Formulate and solve minimum snap trajectory optimization problems</li>
        <li>Handle dynamic obstacles with replanning strategies (D* Lite, velocity obstacles)</li>
        <li>Incorporate energy constraints and geofencing into planning pipelines</li>
        <li>Integrate 3D planners with ROS 2 and OctoMap</li>
    </ul>

    <h2>Why 3D Planning Differs from 2D</h2>
    <div class="two-column">
        <div>
            <h3>Dimensionality Challenges</h3>
            <ul>
                <li><strong>State space explosion:</strong> adding altitude increases grid cells cubically</li>
                <li><strong>More neighbors:</strong> 26-connected vs 8-connected (3.25x more expansions)</li>
                <li><strong>Complex obstacles:</strong> buildings, bridges, power lines, trees</li>
                <li><strong>Gravity:</strong> altitude costs energy; hovering is not free</li>
            </ul>
        </div>
        <div>
            <img src="https://images.unsplash.com/photo-1524143986875-3b098d78b363?w=450&h=300&fit=crop" alt="Urban drone flight environment">
            <div class="image-caption">Figure 2.1: Urban environments present layered 3D obstacles</div>
        </div>
    </div>

    <h3>Drone-Specific Constraints</h3>
    <div class="three-column">
        <div class="sensor-card">
            <h4>Altitude Limits</h4>
            <p>Legal ceiling (120 m in many countries), minimum safe altitude, terrain-following</p>
        </div>
        <div class="sensor-card">
            <h4>No-Fly Zones</h4>
            <p>Airports, military areas, national parks, temporary flight restrictions (TFRs)</p>
        </div>
        <div class="sensor-card">
            <h4>Energy / Battery</h4>
            <p>Limited flight time (20-40 min), altitude costs energy, wind resistance, RTH reserve</p>
        </div>
    </div>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1508444845599-5c89863b1c44?w=900&h=350&fit=crop" alt="City skyline with drone airspace">
        <div class="image-caption">Figure 2.2: Drone airspace management requires understanding of 3D constraints and regulations</div>
    </div>

    <div class="warning-box">
        <strong>Key Insight:</strong> A 2D planner extended naively to 3D can be orders of magnitude slower. For a 1000&times;1000&times;1000 voxel grid, A* may need to explore up to \(10^9\) nodes. This is why sampling-based methods and hierarchical representations are essential.
    </div>
</div>

<!-- ==================== PAGE 3: 3D ENVIRONMENT REPRESENTATION ==================== -->
<div class="page">
    <h2>3D Environment Representation</h2>
    <p>Before planning, we need a representation of the 3D world that a drone can reason about. The four main approaches are voxel grids, octrees, point clouds, and meshes.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1558618666-fcd25c85f82e?w=900&h=300&fit=crop" alt="3D mapping and point cloud">
        <div class="image-caption">Figure 3.1: 3D mapping from LiDAR produces dense point clouds that must be converted to planning-friendly formats</div>
    </div>

    <h3>Comparison of 3D Representations</h3>
    <table>
        <tr><th>Representation</th><th>Memory</th><th>Query Speed</th><th>Resolution</th><th>Best For</th></tr>
        <tr><td>Voxel Grid</td><td>High (O(n&sup3;))</td><td>O(1)</td><td>Fixed uniform</td><td>Small environments, GPU planning</td></tr>
        <tr><td>Octree (OctoMap)</td><td>Low (adaptive)</td><td>O(log n)</td><td>Multi-resolution</td><td>Large outdoor environments</td></tr>
        <tr><td>Point Cloud</td><td>Medium</td><td>O(log n) with KD-tree</td><td>Sensor-dependent</td><td>Raw sensor data, registration</td></tr>
        <tr><td>Mesh (TSDF)</td><td>Medium</td><td>O(log n)</td><td>Continuous surface</td><td>Detailed surface modelling</td></tr>
    </table>

    <h3>Voxel Grid vs Octree Decomposition</h3>
    <div class="image-container">
        <svg viewBox="0 0 800 320" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <!-- Voxel Grid -->
            <text x="140" y="25" font-size="16" font-weight="bold" fill="#667eea" text-anchor="middle">Uniform Voxel Grid</text>
            <rect x="20" y="35" width="240" height="240" fill="none" stroke="#667eea" stroke-width="2"/>
            <!-- Grid lines -->
            <line x1="80" y1="35" x2="80" y2="275" stroke="#ccc" stroke-width="1"/>
            <line x1="140" y1="35" x2="140" y2="275" stroke="#ccc" stroke-width="1"/>
            <line x1="200" y1="35" x2="200" y2="275" stroke="#ccc" stroke-width="1"/>
            <line x1="20" y1="95" x2="260" y2="95" stroke="#ccc" stroke-width="1"/>
            <line x1="20" y1="155" x2="260" y2="155" stroke="#ccc" stroke-width="1"/>
            <line x1="20" y1="215" x2="260" y2="215" stroke="#ccc" stroke-width="1"/>
            <!-- Occupied cells -->
            <rect x="80" y="95" width="60" height="60" fill="#667eea" opacity="0.6"/>
            <rect x="140" y="95" width="60" height="60" fill="#667eea" opacity="0.6"/>
            <rect x="80" y="155" width="60" height="60" fill="#667eea" opacity="0.6"/>
            <rect x="140" y="155" width="60" height="60" fill="#667eea" opacity="0.4"/>
            <text x="140" y="300" font-size="13" fill="#666" text-anchor="middle">All cells same size &mdash; wastes memory in free space</text>

            <!-- Arrow -->
            <text x="400" y="160" font-size="40" fill="#764ba2" text-anchor="middle">&#8594;</text>

            <!-- Octree -->
            <text x="640" y="25" font-size="16" font-weight="bold" fill="#764ba2" text-anchor="middle">Octree (Adaptive)</text>
            <rect x="520" y="35" width="240" height="240" fill="none" stroke="#764ba2" stroke-width="2"/>
            <!-- Large free quadrants -->
            <line x1="640" y1="35" x2="640" y2="275" stroke="#764ba2" stroke-width="1.5"/>
            <line x1="520" y1="155" x2="760" y2="155" stroke="#764ba2" stroke-width="1.5"/>
            <!-- Subdivided top-left -->
            <line x1="580" y1="35" x2="580" y2="155" stroke="#764ba2" stroke-width="1"/>
            <line x1="520" y1="95" x2="640" y2="95" stroke="#764ba2" stroke-width="1"/>
            <!-- Occupied -->
            <rect x="580" y="95" width="60" height="60" fill="#764ba2" opacity="0.6"/>
            <rect x="520" y="95" width="60" height="60" fill="#764ba2" opacity="0.4"/>
            <!-- Further subdivided -->
            <line x1="610" y1="95" x2="610" y2="155" stroke="#764ba2" stroke-width="0.5"/>
            <line x1="580" y1="125" x2="640" y2="125" stroke="#764ba2" stroke-width="0.5"/>
            <rect x="580" y="95" width="30" height="30" fill="#764ba2" opacity="0.8"/>
            <text x="640" y="300" font-size="13" fill="#666" text-anchor="middle">Large free regions stored as single nodes &mdash; memory efficient</text>
        </svg>
        <div class="image-caption">Figure 3.2: Voxel grid vs octree decomposition. Octrees adapt resolution to obstacle density.</div>
    </div>

    <div class="info-box">
        <strong>Memory comparison:</strong> A 100 m &times; 100 m &times; 50 m environment at 0.1 m resolution requires <strong>5 billion voxels</strong> as a dense grid (~5 GB). An octree of the same space typically uses <strong>50-200 MB</strong> depending on obstacle density.
    </div>
</div>

<!-- ==================== PAGE 4: OCTOMAP IN DETAIL ==================== -->
<div class="page">
    <h2>OctoMap in Detail</h2>
    <p>OctoMap is the de facto standard for 3D occupancy mapping in robotics. It uses a hierarchical octree data structure with probabilistic occupancy modelling.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1561144257-e32e8efc6c4f?w=900&h=300&fit=crop" alt="3D mapping visualization">
        <div class="image-caption">Figure 4.1: OctoMap enables efficient 3D occupancy mapping from sensor data</div>
    </div>

    <h3>Hierarchical Octree Structure</h3>
    <div class="image-container">
        <svg viewBox="0 0 700 300" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <!-- Root -->
            <rect x="310" y="10" width="80" height="40" rx="5" fill="#667eea" stroke="#333" stroke-width="1.5"/>
            <text x="350" y="35" font-size="12" fill="white" text-anchor="middle">Root</text>
            <!-- Level 1 -->
            <line x1="350" y1="50" x2="100" y2="90" stroke="#764ba2" stroke-width="1.5"/>
            <line x1="350" y1="50" x2="270" y2="90" stroke="#764ba2" stroke-width="1.5"/>
            <line x1="350" y1="50" x2="430" y2="90" stroke="#764ba2" stroke-width="1.5"/>
            <line x1="350" y1="50" x2="600" y2="90" stroke="#764ba2" stroke-width="1.5"/>
            <rect x="60" y="90" width="80" height="35" rx="5" fill="#764ba2"/>
            <text x="100" y="112" font-size="11" fill="white" text-anchor="middle">Octant 0</text>
            <rect x="230" y="90" width="80" height="35" rx="5" fill="#764ba2"/>
            <text x="270" y="112" font-size="11" fill="white" text-anchor="middle">Octant 1</text>
            <rect x="390" y="90" width="80" height="35" rx="5" fill="#4CAF50"/>
            <text x="430" y="112" font-size="11" fill="white" text-anchor="middle">Free</text>
            <rect x="560" y="90" width="80" height="35" rx="5" fill="#4CAF50"/>
            <text x="600" y="112" font-size="11" fill="white" text-anchor="middle">Free</text>
            <!-- Level 2 from Octant 0 -->
            <line x1="100" y1="125" x2="40" y2="170" stroke="#667eea" stroke-width="1"/>
            <line x1="100" y1="125" x2="100" y2="170" stroke="#667eea" stroke-width="1"/>
            <line x1="100" y1="125" x2="160" y2="170" stroke="#667eea" stroke-width="1"/>
            <rect x="15" y="170" width="50" height="30" rx="4" fill="#e74c3c"/>
            <text x="40" y="190" font-size="10" fill="white" text-anchor="middle">Occ</text>
            <rect x="75" y="170" width="50" height="30" rx="4" fill="#4CAF50"/>
            <text x="100" y="190" font-size="10" fill="white" text-anchor="middle">Free</text>
            <rect x="135" y="170" width="50" height="30" rx="4" fill="#e74c3c"/>
            <text x="160" y="190" font-size="10" fill="white" text-anchor="middle">Occ</text>
            <!-- Level 2 from Octant 1 -->
            <line x1="270" y1="125" x2="230" y2="170" stroke="#667eea" stroke-width="1"/>
            <line x1="270" y1="125" x2="310" y2="170" stroke="#667eea" stroke-width="1"/>
            <rect x="205" y="170" width="50" height="30" rx="4" fill="#4CAF50"/>
            <text x="230" y="190" font-size="10" fill="white" text-anchor="middle">Free</text>
            <rect x="285" y="170" width="50" height="30" rx="4" fill="#4CAF50"/>
            <text x="310" y="190" font-size="10" fill="white" text-anchor="middle">Free</text>
            <!-- Legend -->
            <rect x="200" y="240" width="15" height="15" fill="#e74c3c"/>
            <text x="220" y="253" font-size="12" fill="#333">Occupied</text>
            <rect x="310" y="240" width="15" height="15" fill="#4CAF50"/>
            <text x="330" y="253" font-size="12" fill="#333">Free</text>
            <rect x="410" y="240" width="15" height="15" fill="#764ba2"/>
            <text x="430" y="253" font-size="12" fill="#333">Mixed (subdivided)</text>
            <text x="350" y="290" font-size="13" fill="#666" text-anchor="middle">Each node has 8 children; free/occupied leaves are not subdivided further</text>
        </svg>
        <div class="image-caption">Figure 4.2: Octree structure. Uniform regions (all free/occupied) are stored as single leaf nodes, saving memory.</div>
    </div>

    <h3>Occupancy Probability Update</h3>
    <p>Each voxel stores a log-odds occupancy value updated via a sensor model:</p>
    <div class="math">
        \[ L(n \mid z_{1:t}) = L(n \mid z_{1:t-1}) + L(n \mid z_t) - L_0 \]
    </div>
    <p>Where \(L(n) = \log\frac{P(n)}{1 - P(n)}\) is the log-odds representation, \(z_t\) is the current sensor measurement, and \(L_0 = L(P_{\text{prior}})\) is the prior.</p>

    <div class="math">
        \[ P(n \mid z_{1:t}) = 1 - \frac{1}{1 + \exp(L(n \mid z_{1:t}))} \]
    </div>

    <div class="info-box">
        <strong>Clamping:</strong> OctoMap clamps log-odds to \([L_{\min}, L_{\max}]\) to allow the map to adapt when the environment changes. Typical values: \(L_{\min} = -2, \; L_{\max} = 3.5\).
    </div>

    <h3>Key Properties</h3>
    <ul>
        <li><strong>Multi-resolution queries:</strong> query at coarse resolution for fast planning, fine resolution near obstacles</li>
        <li><strong>Lossless compression:</strong> inner nodes pruned when all children agree</li>
        <li><strong>Dynamic updates:</strong> incremental ray-casting for real-time sensor integration</li>
        <li><strong>Serialization:</strong> compact binary format for storage and transmission</li>
    </ul>
</div>

<!-- ==================== PAGE 5: CONFIGURATION SPACE ==================== -->
<div class="page">
    <h2>Configuration Space for Drones</h2>
    <p>A multirotor drone in free flight has 6 degrees of freedom (x, y, z, roll, pitch, yaw). For path planning, we typically reduce this to <strong>4 DOF</strong>: 3D position + yaw, because the flight controller handles roll and pitch to achieve desired velocities.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1579829366248-204fe8413f31?w=900&h=350&fit=crop" alt="Drone in flight showing axes">
        <div class="image-caption">Figure 5.1: Drone configuration space: position (x, y, z) and heading (yaw)</div>
    </div>

    <h3>Obstacle Inflation for Drone Radius</h3>
    <p>To treat the drone as a point in C-space, we <strong>inflate</strong> all obstacles by the drone's bounding radius \(r_d\):</p>
    <div class="math">
        \[ \mathcal{C}_{\text{obs}} = \{ \mathbf{q} \in \mathcal{C} \mid \exists \mathbf{p} \in \mathcal{O} : \|\mathbf{q} - \mathbf{p}\| \leq r_d + r_{\text{safety}} \} \]
    </div>
    <p><strong>where:</strong></p>
    <ul>
        <li>\( \mathcal{C} \) — configuration space</li>
        <li>\( \mathcal{C}_{\text{obs}} \) — obstacle region in configuration space</li>
        <li>\( \mathcal{O} \) — set of obstacle points in the workspace</li>
        <li>\( r_d \) — bounding radius of the drone</li>
        <li>\( r_{\text{safety}} \) — additional safety margin (typically 0.3-0.5 m for outdoor flights)</li>
    </ul>

    <div class="image-container">
        <svg viewBox="0 0 700 300" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <!-- Workspace -->
            <text x="175" y="25" font-size="15" font-weight="bold" fill="#667eea" text-anchor="middle">Workspace</text>
            <rect x="20" y="35" width="310" height="240" fill="#f0f8ff" stroke="#667eea" stroke-width="2" rx="5"/>
            <!-- Obstacle -->
            <rect x="100" y="100" width="80" height="100" fill="#e74c3c" rx="3"/>
            <text x="140" y="155" font-size="11" fill="white" text-anchor="middle">Obstacle</text>
            <!-- Drone symbol -->
            <circle cx="250" cy="150" r="15" fill="none" stroke="#667eea" stroke-width="2"/>
            <line x1="235" y1="150" x2="265" y2="150" stroke="#667eea" stroke-width="2"/>
            <line x1="250" y1="135" x2="250" y2="165" stroke="#667eea" stroke-width="2"/>
            <text x="250" y="185" font-size="10" fill="#667eea" text-anchor="middle">Drone (r=15)</text>

            <!-- Arrow -->
            <text x="370" y="160" font-size="30" fill="#764ba2">&#8594;</text>

            <!-- C-space -->
            <text x="545" y="25" font-size="15" font-weight="bold" fill="#764ba2" text-anchor="middle">C-Space (inflated)</text>
            <rect x="390" y="35" width="310" height="240" fill="#faf0ff" stroke="#764ba2" stroke-width="2" rx="5"/>
            <!-- Inflated obstacle -->
            <rect x="455" y="80" width="110" height="130" fill="#e74c3c" opacity="0.3" rx="3"/>
            <rect x="470" y="95" width="80" height="100" fill="#e74c3c" rx="3"/>
            <text x="510" y="150" font-size="11" fill="white" text-anchor="middle">Inflated</text>
            <!-- Point drone -->
            <circle cx="620" cy="150" r="4" fill="#764ba2"/>
            <text x="620" y="175" font-size="10" fill="#764ba2" text-anchor="middle">Point robot</text>
            <!-- Dimension arrows for inflation -->
            <line x1="455" y1="220" x2="470" y2="220" stroke="#ff9800" stroke-width="2" marker-end="url(#arrowOrange)"/>
            <text x="462" y="238" font-size="9" fill="#ff9800" text-anchor="middle">r_d</text>
            <defs><marker id="arrowOrange" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="#ff9800"/></marker></defs>
        </svg>
        <div class="image-caption">Figure 5.2: C-space obstacle inflation. Obstacles grow by drone radius, allowing point-based planning.</div>
    </div>

    <h3>Altitude Constraints</h3>
    <div class="two-column">
        <div class="info-box">
            <h4>Hard Constraints</h4>
            <ul>
                <li>\(z_{\min} \leq z \leq z_{\max}\) (legal altitude band)</li>
                <li>Terrain clearance: \(z \geq z_{\text{terrain}}(x,y) + h_{\text{min}}\)</li>
                <li>No-fly zone avoidance (3D volumes)</li>
            </ul>
        </div>
        <div class="info-box">
            <h4>Soft Constraints</h4>
            <ul>
                <li>Prefer lower altitudes (energy saving)</li>
                <li>Prefer higher altitudes (obstacle clearance)</li>
                <li>Wind avoidance at certain altitudes</li>
            </ul>
        </div>
    </div>

    <div class="activity-box">
        <h3>Activity 1: C-Space Inflation</h3>
        <p><strong>Task:</strong> Given a cylindrical obstacle at position (5, 3, 0) with radius 1.0 m and height 10 m, and a drone with bounding radius 0.4 m and safety margin 0.3 m:</p>
        <ol>
            <li>Calculate the inflated obstacle radius in the horizontal plane.</li>
            <li>Determine the inflated obstacle height.</li>
            <li>Write a function <code>is_collision(x, y, z, obs)</code> that checks if a point is inside the inflated obstacle.</li>
        </ol>
        <p><strong>Expected inflated radius:</strong> \(1.0 + 0.4 + 0.3 = 1.7\) m</p>
    </div>
</div>

<!-- ==================== PAGE 6: GRAPH-BASED 3D PLANNING ==================== -->
<div class="page">
    <h2>Graph-Based 3D Planning</h2>
    <p>Graph-based planners discretize the 3D space into a grid and search for shortest paths. The key extension from 2D is the <strong>26-connected neighborhood</strong>.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=900&h=300&fit=crop" alt="Graph network visualization">
        <div class="image-caption">Figure 6.1: Graph search explores nodes systematically to find optimal paths</div>
    </div>

    <h3>26-Connected Grid</h3>
    <div class="image-container">
        <svg viewBox="0 0 700 350" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <!-- 3D cube wireframe showing center node and connections -->
            <!-- Back face -->
            <polygon points="250,50 400,50 430,80 280,80" fill="none" stroke="#ccc" stroke-width="1"/>
            <polygon points="250,200 400,200 430,230 280,230" fill="none" stroke="#ccc" stroke-width="1"/>
            <line x1="250" y1="50" x2="250" y2="200" stroke="#ccc" stroke-width="1"/>
            <line x1="400" y1="50" x2="400" y2="200" stroke="#ccc" stroke-width="1"/>
            <!-- Front face -->
            <polygon points="280,80 430,80 430,230 280,230" fill="none" stroke="#667eea" stroke-width="1.5"/>
            <line x1="280" y1="80" x2="280" y2="230" stroke="#667eea" stroke-width="1.5"/>
            <line x1="430" y1="80" x2="430" y2="230" stroke="#667eea" stroke-width="1.5"/>
            <!-- Center node -->
            <circle cx="340" cy="140" r="8" fill="#e74c3c"/>
            <!-- Corner nodes (26 neighbors) -->
            <circle cx="250" cy="50" r="5" fill="#667eea"/>
            <circle cx="400" cy="50" r="5" fill="#667eea"/>
            <circle cx="280" cy="80" r="5" fill="#667eea"/>
            <circle cx="430" cy="80" r="5" fill="#667eea"/>
            <circle cx="250" cy="200" r="5" fill="#667eea"/>
            <circle cx="400" cy="200" r="5" fill="#667eea"/>
            <circle cx="280" cy="230" r="5" fill="#667eea"/>
            <circle cx="430" cy="230" r="5" fill="#667eea"/>
            <!-- Face centers -->
            <circle cx="325" cy="50" r="4" fill="#764ba2"/>
            <circle cx="325" cy="200" r="4" fill="#764ba2"/>
            <circle cx="355" cy="80" r="4" fill="#764ba2"/>
            <circle cx="355" cy="230" r="4" fill="#764ba2"/>
            <circle cx="250" cy="125" r="4" fill="#764ba2"/>
            <circle cx="430" cy="155" r="4" fill="#764ba2"/>
            <!-- Lines from center to some neighbors -->
            <line x1="340" y1="140" x2="250" y2="50" stroke="#e74c3c" stroke-width="1" stroke-dasharray="4,3"/>
            <line x1="340" y1="140" x2="430" y2="230" stroke="#e74c3c" stroke-width="1" stroke-dasharray="4,3"/>
            <line x1="340" y1="140" x2="355" y2="80" stroke="#e74c3c" stroke-width="1" stroke-dasharray="4,3"/>
            <line x1="340" y1="140" x2="325" y2="200" stroke="#e74c3c" stroke-width="1" stroke-dasharray="4,3"/>
            <!-- Labels -->
            <text x="340" y="170" font-size="12" fill="#e74c3c" text-anchor="middle">Center node</text>
            <text x="340" y="280" font-size="14" fill="#333" text-anchor="middle">6 face + 12 edge + 8 corner = 26 neighbors</text>
            <!-- Legend -->
            <text x="520" y="100" font-size="12" fill="#333">Costs:</text>
            <text x="520" y="120" font-size="11" fill="#764ba2">Face: 1.0</text>
            <text x="520" y="140" font-size="11" fill="#667eea">Edge: &#8730;2 &asymp; 1.41</text>
            <text x="520" y="160" font-size="11" fill="#e74c3c">Corner: &#8730;3 &asymp; 1.73</text>
            <text x="340" y="310" font-size="13" fill="#666" text-anchor="middle">3D grid connectivity: each interior voxel connects to 26 neighbors</text>
        </svg>
        <div class="image-caption">Figure 6.2: 26-connected 3D grid. Movement costs depend on neighbor type.</div>
    </div>

    <h3>3D A* Heuristic</h3>
    <p>The 3D Euclidean heuristic is admissible and consistent:</p>
    <div class="math">
        \[ h(\mathbf{n}) = \sqrt{(x_n - x_g)^2 + (y_n - y_g)^2 + (z_n - z_g)^2} \]
    </div>
    <p>The 3D diagonal (Chebyshev-like) heuristic is tighter:</p>
    <div class="math">
        \[ h(\mathbf{n}) = (\sqrt{3} - \sqrt{2})\,d_3 + (\sqrt{2} - 1)\,d_2 + d_1 \]
    </div>
    <p>where \(d_1 \geq d_2 \geq d_3\) are the sorted absolute differences \(|x_n - x_g|, |y_n - y_g|, |z_n - z_g|\).</p>

    <h3>Complexity Analysis</h3>
    <table>
        <tr><th>Algorithm</th><th>Time Complexity</th><th>Space Complexity</th><th>Optimal?</th></tr>
        <tr><td>3D Dijkstra</td><td>\(O(N \log N)\), \(N = n_x n_y n_z\)</td><td>\(O(N)\)</td><td>Yes</td></tr>
        <tr><td>3D A*</td><td>\(O(N \log N)\) worst case</td><td>\(O(N)\)</td><td>Yes (admissible h)</td></tr>
        <tr><td>3D Weighted A*</td><td>Faster in practice</td><td>\(O(N)\)</td><td>\(\epsilon\)-optimal</td></tr>
    </table>

    <div class="warning-box">
        <strong>Scalability problem:</strong> For a 500&times;500&times;100 grid (25 million nodes), even A* can take seconds. This motivates sampling-based planners for larger environments.
    </div>
</div>

<!-- ==================== PAGE 7: 3D A* IMPLEMENTATION ==================== -->
<div class="page">
    <h2>3D A* Implementation</h2>

    <h3>Data Structures</h3>
    <ul>
        <li><strong>Open set:</strong> min-heap / priority queue keyed by \(f = g + h\)</li>
        <li><strong>Closed set:</strong> 3D boolean array or hash set of visited nodes</li>
        <li><strong>g-values:</strong> 3D array storing cost-to-come</li>
        <li><strong>Parent map:</strong> 3D array or dict for path reconstruction</li>
    </ul>

    <h3>Python Pseudocode</h3>
    <pre>
import heapq
import numpy as np

def astar_3d(grid, start, goal):
    """3D A* on a voxel grid. grid[x,y,z]=1 means occupied."""
    nx, ny, nz = grid.shape
    # 26-connected neighbors: all (dx,dy,dz) combos except (0,0,0)
    neighbors = [(dx,dy,dz)
                 for dx in (-1,0,1) for dy in (-1,0,1) for dz in (-1,0,1)
                 if not (dx==0 and dy==0 and dz==0)]
    costs = {n: np.sqrt(n[0]**2+n[1]**2+n[2]**2) for n in neighbors}

    g = np.full((nx,ny,nz), np.inf)
    g[start] = 0.0
    parent = {}
    closed = np.zeros((nx,ny,nz), dtype=bool)

    def heuristic(node):
        return np.sqrt(sum((a-b)**2 for a,b in zip(node, goal)))

    open_set = [(heuristic(start), start)]

    while open_set:
        f_val, current = heapq.heappop(open_set)
        if current == goal:
            return reconstruct_path(parent, goal)
        if closed[current]:
            continue
        closed[current] = True

        for d in neighbors:
            nb = (current[0]+d[0], current[1]+d[1], current[2]+d[2])
            if not (0&lt;=nb[0]&lt;nx and 0&lt;=nb[1]&lt;ny and 0&lt;=nb[2]&lt;nz):
                continue
            if grid[nb] == 1 or closed[nb]:
                continue
            new_g = g[current] + costs[d]
            if new_g &lt; g[nb]:
                g[nb] = new_g
                parent[nb] = current
                heapq.heappush(open_set, (new_g + heuristic(nb), nb))

    return None  # No path found

def reconstruct_path(parent, goal):
    path = [goal]
    while path[-1] in parent:
        path.append(parent[path[-1]])
    return path[::-1]
    </pre>

    <h3>Complexity Comparison for 3D Grids</h3>
    <table>
        <tr><th>Grid Size</th><th>Total Nodes</th><th>A* Typical Expanded</th><th>Approx. Time</th></tr>
        <tr><td>100&sup3;</td><td>1 M</td><td>50 K - 200 K</td><td>0.1 - 0.5 s</td></tr>
        <tr><td>200&sup3;</td><td>8 M</td><td>200 K - 1 M</td><td>0.5 - 3 s</td></tr>
        <tr><td>500&sup3;</td><td>125 M</td><td>1 M - 10 M</td><td>5 - 60 s</td></tr>
        <tr><td>1000&sup3;</td><td>1 B</td><td>Often infeasible</td><td>Minutes+</td></tr>
    </table>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1518770660439-4636190af475?w=900&h=300&fit=crop" alt="Algorithm computation visualization">
        <div class="image-caption">Figure 7.1: Computational efficiency is critical for real-time drone planning</div>
    </div>

    <div class="tip">
        Use <strong>weighted A*</strong> with \(f = g + \epsilon \cdot h\) where \(\epsilon > 1\) for faster (suboptimal) solutions. The solution cost is at most \(\epsilon\) times optimal.
    </div>
</div>

<!-- ==================== PAGE 8: RRT ==================== -->
<div class="page">
    <h2>Sampling-Based Planning: RRT</h2>
    <p>The <strong>Rapidly-exploring Random Tree (RRT)</strong> algorithm builds a tree by randomly sampling the configuration space. It is especially effective in high-dimensional spaces where grid-based methods are infeasible.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1635070041078-e363dbe005cb?w=900&h=300&fit=crop" alt="Tree branching structure">
        <div class="image-caption">Figure 8.1: RRT grows a tree-like structure to explore the configuration space</div>
    </div>

    <h3>Why Sampling Works in High Dimensions</h3>
    <div class="info-box">
        <p>Grid-based methods scale as \(O(n^d)\) where \(d\) is dimension. RRT scales <strong>independently</strong> of the ambient dimension -- its complexity depends on the geometric difficulty of the problem, not the resolution of a grid.</p>
    </div>

    <h3>RRT Algorithm</h3>
    <div class="diagram">
        <div class="flow-step">1. Initialize tree T with start node</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">2. Sample random point q_rand in C-space</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">3. Find nearest node q_near in T to q_rand</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">4. Steer from q_near toward q_rand by step size &eta; &rarr; q_new</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">5. If edge (q_near, q_new) is collision-free, add q_new to T</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">6. If q_new is near goal, connect and return path</div>
    </div>

    <h3>RRT Tree Growth Visualization</h3>
    <div class="image-container">
        <svg viewBox="0 0 700 320" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <!-- Boundary -->
            <rect x="20" y="20" width="660" height="280" fill="#f9f9f9" stroke="#667eea" stroke-width="2" rx="5"/>
            <!-- Obstacles -->
            <rect x="200" y="80" width="80" height="120" fill="#e74c3c" opacity="0.7" rx="5"/>
            <circle cx="480" cy="180" r="50" fill="#e74c3c" opacity="0.7"/>
            <!-- Start -->
            <circle cx="60" cy="150" r="10" fill="#4CAF50"/>
            <text x="60" y="180" font-size="11" fill="#4CAF50" text-anchor="middle">Start</text>
            <!-- Goal -->
            <circle cx="640" cy="150" r="10" fill="#ff9800"/>
            <text x="640" y="180" font-size="11" fill="#ff9800" text-anchor="middle">Goal</text>
            <!-- Tree branches -->
            <line x1="60" y1="150" x2="110" y2="120" stroke="#667eea" stroke-width="1.5"/>
            <line x1="60" y1="150" x2="100" y2="190" stroke="#667eea" stroke-width="1.5"/>
            <line x1="60" y1="150" x2="90" y2="140" stroke="#667eea" stroke-width="1.5"/>
            <line x1="110" y1="120" x2="160" y2="60" stroke="#667eea" stroke-width="1.5"/>
            <line x1="110" y1="120" x2="170" y2="100" stroke="#667eea" stroke-width="1.5"/>
            <line x1="100" y1="190" x2="150" y2="230" stroke="#667eea" stroke-width="1.5"/>
            <line x1="150" y1="230" x2="200" y2="260" stroke="#667eea" stroke-width="1.5"/>
            <line x1="200" y1="260" x2="300" y2="250" stroke="#667eea" stroke-width="1.5"/>
            <line x1="300" y1="250" x2="360" y2="230" stroke="#667eea" stroke-width="1.5"/>
            <line x1="160" y1="60" x2="300" y2="50" stroke="#667eea" stroke-width="1.5"/>
            <line x1="300" y1="50" x2="400" y2="60" stroke="#667eea" stroke-width="1.5"/>
            <line x1="400" y1="60" x2="500" y2="80" stroke="#667eea" stroke-width="1.5"/>
            <line x1="500" y1="80" x2="560" y2="100" stroke="#667eea" stroke-width="1.5"/>
            <line x1="560" y1="100" x2="600" y2="130" stroke="#667eea" stroke-width="1.5"/>
            <line x1="600" y1="130" x2="640" y2="150" stroke="#4CAF50" stroke-width="2.5"/>
            <line x1="360" y1="230" x2="420" y2="260" stroke="#667eea" stroke-width="1.5"/>
            <line x1="360" y1="230" x2="380" y2="280" stroke="#667eea" stroke-width="1.5"/>
            <line x1="90" y1="140" x2="130" y2="160" stroke="#667eea" stroke-width="1.5"/>
            <!-- Nodes -->
            <circle cx="110" cy="120" r="3" fill="#764ba2"/>
            <circle cx="100" cy="190" r="3" fill="#764ba2"/>
            <circle cx="90" cy="140" r="3" fill="#764ba2"/>
            <circle cx="160" cy="60" r="3" fill="#764ba2"/>
            <circle cx="170" cy="100" r="3" fill="#764ba2"/>
            <circle cx="150" cy="230" r="3" fill="#764ba2"/>
            <circle cx="200" cy="260" r="3" fill="#764ba2"/>
            <circle cx="300" cy="250" r="3" fill="#764ba2"/>
            <circle cx="300" cy="50" r="3" fill="#764ba2"/>
            <circle cx="400" cy="60" r="3" fill="#764ba2"/>
            <circle cx="500" cy="80" r="3" fill="#764ba2"/>
            <circle cx="560" cy="100" r="3" fill="#764ba2"/>
            <circle cx="600" cy="130" r="3" fill="#764ba2"/>
            <circle cx="360" cy="230" r="3" fill="#764ba2"/>
            <circle cx="420" cy="260" r="3" fill="#764ba2"/>
            <circle cx="380" cy="280" r="3" fill="#764ba2"/>
            <circle cx="130" cy="160" r="3" fill="#764ba2"/>
        </svg>
        <div class="image-caption">Figure 8.2: RRT tree expanding through free space, avoiding obstacles, to reach the goal</div>
    </div>

    <div class="warning-box">
        <strong>RRT Limitation:</strong> RRT finds <em>a</em> path but not the <em>optimal</em> path. Paths are typically jerky and far from optimal. This motivates RRT* and trajectory optimization as post-processing.
    </div>
</div>

<!-- ==================== PAGE 9: RRT* ==================== -->
<div class="page">
    <h2>RRT* (Optimal RRT)</h2>
    <p>RRT* extends RRT with two key operations: <strong>near-neighbor search</strong> and <strong>rewiring</strong>. It is <strong>asymptotically optimal</strong> -- the solution converges to the true optimum as the number of samples grows.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1509228627152-72ae9ae6848d?w=900&h=300&fit=crop" alt="Optimized network paths">
        <div class="image-caption">Figure 9.1: RRT* progressively improves path quality through rewiring</div>
    </div>

    <h3>Cost Function</h3>
    <div class="math">
        \[ \text{Cost}(q_{\text{new}}) = \min_{q_{\text{near}} \in \mathcal{N}(q_{\text{new}})} \left[ \text{Cost}(q_{\text{near}}) + c(q_{\text{near}}, q_{\text{new}}) \right] \]
    </div>
    <p>where \(c(q_1, q_2) = \|q_1 - q_2\|\) is the edge cost and \(\mathcal{N}(q)\) is the set of near neighbors.</p>

    <h3>Rewiring Radius</h3>
    <p>The near-neighbor radius shrinks as the tree grows:</p>
    <div class="math">
        \[ r_n = \min\left(\gamma \left(\frac{\log n}{n}\right)^{1/d}, \eta \right), \quad \gamma = 2\left(1 + \frac{1}{d}\right)^{1/d} \left(\frac{\mu(\mathcal{X}_{\text{free}})}{\zeta_d}\right)^{1/d} \]
    </div>
    <p>where \(n\) is the number of nodes, \(d\) is dimension (3 for 3D), \(\mu(\mathcal{X}_{\text{free}})\) is the volume of free space, and \(\zeta_d\) is the volume of a unit \(d\)-ball.</p>

    <h3>RRT vs RRT* Comparison</h3>
    <div class="image-container">
        <svg viewBox="0 0 700 280" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <!-- RRT side -->
            <text x="170" y="20" font-size="15" font-weight="bold" fill="#667eea" text-anchor="middle">RRT (non-optimal)</text>
            <rect x="20" y="30" width="300" height="230" fill="#f9f9f9" stroke="#667eea" stroke-width="2" rx="5"/>
            <rect x="120" y="80" width="50" height="80" fill="#e74c3c" opacity="0.5" rx="3"/>
            <circle cx="50" cy="140" r="8" fill="#4CAF50"/>
            <circle cx="290" cy="140" r="8" fill="#ff9800"/>
            <!-- Jerky RRT path -->
            <polyline points="50,140 80,100 100,60 120,50 180,45 220,70 250,110 270,90 290,140" fill="none" stroke="#667eea" stroke-width="2.5"/>
            <text x="170" y="275" font-size="12" fill="#666" text-anchor="middle">Jerky, suboptimal path</text>

            <!-- RRT* side -->
            <text x="530" y="20" font-size="15" font-weight="bold" fill="#764ba2" text-anchor="middle">RRT* (asymptotically optimal)</text>
            <rect x="380" y="30" width="300" height="230" fill="#faf0ff" stroke="#764ba2" stroke-width="2" rx="5"/>
            <rect x="480" y="80" width="50" height="80" fill="#e74c3c" opacity="0.5" rx="3"/>
            <circle cx="410" cy="140" r="8" fill="#4CAF50"/>
            <circle cx="650" cy="140" r="8" fill="#ff9800"/>
            <!-- Smooth RRT* path -->
            <path d="M410,140 Q440,130 460,100 Q480,70 520,60 Q560,55 590,80 Q620,105 650,140" fill="none" stroke="#764ba2" stroke-width="2.5"/>
            <!-- Rewired branches (faint) -->
            <line x1="460" y1="100" x2="450" y2="180" stroke="#764ba2" stroke-width="0.8" opacity="0.3"/>
            <line x1="520" y1="60" x2="540" y2="170" stroke="#764ba2" stroke-width="0.8" opacity="0.3"/>
            <line x1="590" y1="80" x2="610" y2="200" stroke="#764ba2" stroke-width="0.8" opacity="0.3"/>
            <text x="530" y="275" font-size="12" fill="#666" text-anchor="middle">Smoother, converging to optimal</text>
        </svg>
        <div class="image-caption">Figure 9.2: RRT produces jerky paths; RRT* rewires to progressively improve toward optimality</div>
    </div>

    <h3>RRT* Key Steps (beyond RRT)</h3>
    <ol>
        <li><strong>Choose best parent:</strong> Among all near neighbors of \(q_{\text{new}}\), pick the one that yields lowest cost-to-come.</li>
        <li><strong>Rewire:</strong> For each near neighbor, check if routing through \(q_{\text{new}}\) reduces its cost. If so, rewire its parent to \(q_{\text{new}}\).</li>
    </ol>

    <div class="activity-box">
        <h3>Activity 2: RRT vs RRT* Comparison</h3>
        <p><strong>Task:</strong> Implement both RRT and RRT* for a simple 3D environment with 3 box obstacles. Compare:</p>
        <ol>
            <li>Path length after 1000, 5000, and 10000 samples</li>
            <li>Computation time for each variant</li>
            <li>Path smoothness (sum of angular changes)</li>
        </ol>
        <p><strong>Expected finding:</strong> RRT* path cost decreases with more samples; RRT does not improve.</p>
    </div>
</div>

<!-- ==================== PAGE 10: INFORMED RRT* & BIT* ==================== -->
<div class="page">
    <h2>Informed RRT* &amp; BIT*</h2>

    <h3>Informed RRT*</h3>
    <p>Once an initial solution of cost \(c_{\text{best}}\) is found, Informed RRT* restricts sampling to a <strong>prolate hyperellipsoid</strong> that contains all points that could improve the solution.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1635241161466-541f065683ba?w=900&h=300&fit=crop" alt="Elliptical optimization region">
        <div class="image-caption">Figure 10.1: Informed sampling focuses computational effort on the region that can improve the solution</div>
    </div>

    <h3>Sampling Ellipsoid</h3>
    <p>The ellipsoid is defined by the start \(\mathbf{x}_s\), goal \(\mathbf{x}_g\), and current best cost \(c_{\text{best}}\):</p>
    <div class="math">
        \[ \mathcal{E} = \left\{ \mathbf{x} \in \mathbb{R}^d \;\middle|\; \|\mathbf{x} - \mathbf{x}_s\| + \|\mathbf{x} - \mathbf{x}_g\| \leq c_{\text{best}} \right\} \]
    </div>
    <p>Sampling from this ellipsoid is done by transforming uniform samples from a unit ball:</p>
    <div class="math">
        \[ \mathbf{x}_{\text{sample}} = \mathbf{C} \mathbf{L} \mathbf{x}_{\text{ball}} + \mathbf{x}_{\text{centre}} \]
    </div>
    <p>where \(\mathbf{C}\) is the rotation matrix aligning the ellipsoid with \(\mathbf{x}_g - \mathbf{x}_s\), \(\mathbf{L} = \text{diag}(c_{\text{best}}/2, \; r, \; r)\) with \(r = \frac{1}{2}\sqrt{c_{\text{best}}^2 - c_{\min}^2}\), and \(c_{\min} = \|\mathbf{x}_g - \mathbf{x}_s\|\).</p>

    <h3>BIT* (Batch Informed Trees)</h3>
    <p>BIT* combines the benefits of graph-based and sampling-based planning by processing samples in <strong>batches</strong>:</p>
    <ol>
        <li>Generate a batch of \(m\) samples in the informed ellipsoid</li>
        <li>Build a graph connecting samples to near neighbors</li>
        <li>Search this graph using an A*-like strategy</li>
        <li>Prune, generate new batch, repeat until time budget exhausted</li>
    </ol>

    <h3>Performance Comparison</h3>
    <table>
        <tr><th>Algorithm</th><th>Optimal?</th><th>Convergence Rate</th><th>Anytime?</th><th>Best For</th></tr>
        <tr><td>RRT</td><td>No</td><td>N/A</td><td>No</td><td>Feasibility check</td></tr>
        <tr><td>RRT*</td><td>Asymptotic</td><td>Slow</td><td>Yes</td><td>General optimal planning</td></tr>
        <tr><td>Informed RRT*</td><td>Asymptotic</td><td>Fast</td><td>Yes</td><td>Focused improvement</td></tr>
        <tr><td>BIT*</td><td>Asymptotic</td><td>Fastest</td><td>Yes</td><td>High-dimensional, time-limited</td></tr>
    </table>

    <div class="info-box">
        <strong>Practical Guidance:</strong> For real-time drone planning with time budgets of 0.5-2 seconds, BIT* or Informed RRT* are the recommended choices. They quickly find a feasible path and then refine it within the remaining time.
    </div>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1550751827-4bd374c3f58b?w=900&h=250&fit=crop" alt="Computational optimization">
        <div class="image-caption">Figure 10.2: Advanced planners balance computation time and solution quality</div>
    </div>
</div>

<!-- ==================== PAGE 11: PRM ==================== -->
<div class="page">
    <h2>PRM (Probabilistic Roadmap)</h2>
    <p>Unlike RRT (single-query), PRM is a <strong>multi-query</strong> planner: it builds a reusable roadmap of the free space that can answer many start-goal queries efficiently.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1460925895917-afdab827c52f?w=900&h=300&fit=crop" alt="Network roadmap">
        <div class="image-caption">Figure 11.1: PRM constructs a roadmap graph that can serve multiple planning queries</div>
    </div>

    <h3>Two-Phase Approach</h3>
    <div class="two-column">
        <div class="diagram">
            <h4>Phase 1: Construction (offline)</h4>
            <div class="flow-step">Sample N random configurations</div>
            <div class="arrow">&darr;</div>
            <div class="flow-step">For each sample, find k nearest neighbors</div>
            <div class="arrow">&darr;</div>
            <div class="flow-step">Connect collision-free edges</div>
            <div class="arrow">&darr;</div>
            <div class="flow-step">Store roadmap graph G = (V, E)</div>
        </div>
        <div class="diagram">
            <h4>Phase 2: Query (online)</h4>
            <div class="flow-step">Connect start &amp; goal to nearest roadmap nodes</div>
            <div class="arrow">&darr;</div>
            <div class="flow-step">Search roadmap with A* / Dijkstra</div>
            <div class="arrow">&darr;</div>
            <div class="flow-step">Return path through roadmap</div>
        </div>
    </div>

    <h3>PRM Roadmap Visualization</h3>
    <div class="image-container">
        <svg viewBox="0 0 700 300" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <rect x="10" y="10" width="680" height="280" fill="#f9f9f9" stroke="#667eea" stroke-width="2" rx="5"/>
            <!-- Obstacles -->
            <rect x="200" y="80" width="70" height="100" fill="#e74c3c" opacity="0.6" rx="5"/>
            <circle cx="480" cy="180" r="45" fill="#e74c3c" opacity="0.6"/>
            <!-- Roadmap nodes and edges -->
            <line x1="60" y1="60" x2="150" y2="50" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="60" y1="60" x2="80" y2="140" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="150" y1="50" x2="180" y2="120" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="80" y1="140" x2="150" y2="200" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="150" y1="200" x2="180" y2="250" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="180" y1="250" x2="300" y2="240" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="300" y1="240" x2="350" y2="200" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="150" y1="50" x2="300" y2="40" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="300" y1="40" x2="400" y2="60" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="400" y1="60" x2="500" y2="80" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="500" y1="80" x2="580" y2="100" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="580" y1="100" x2="640" y2="150" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="350" y1="200" x2="400" y2="260" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="400" y1="260" x2="550" y2="250" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="550" y1="250" x2="640" y2="200" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <line x1="640" y1="150" x2="640" y2="200" stroke="#667eea" stroke-width="1" opacity="0.5"/>
            <!-- Nodes -->
            <circle cx="60" cy="60" r="4" fill="#764ba2"/>
            <circle cx="150" cy="50" r="4" fill="#764ba2"/>
            <circle cx="80" cy="140" r="4" fill="#764ba2"/>
            <circle cx="180" cy="120" r="4" fill="#764ba2"/>
            <circle cx="150" cy="200" r="4" fill="#764ba2"/>
            <circle cx="180" cy="250" r="4" fill="#764ba2"/>
            <circle cx="300" cy="240" r="4" fill="#764ba2"/>
            <circle cx="300" cy="40" r="4" fill="#764ba2"/>
            <circle cx="400" cy="60" r="4" fill="#764ba2"/>
            <circle cx="500" cy="80" r="4" fill="#764ba2"/>
            <circle cx="580" cy="100" r="4" fill="#764ba2"/>
            <circle cx="640" cy="150" r="4" fill="#764ba2"/>
            <circle cx="350" cy="200" r="4" fill="#764ba2"/>
            <circle cx="400" cy="260" r="4" fill="#764ba2"/>
            <circle cx="550" cy="250" r="4" fill="#764ba2"/>
            <circle cx="640" cy="200" r="4" fill="#764ba2"/>
            <!-- Path highlight -->
            <polyline points="60,60 150,50 300,40 400,60 500,80 580,100 640,150" fill="none" stroke="#4CAF50" stroke-width="3"/>
            <!-- Start / Goal -->
            <circle cx="60" cy="60" r="8" fill="none" stroke="#4CAF50" stroke-width="2"/>
            <circle cx="640" cy="150" r="8" fill="none" stroke="#ff9800" stroke-width="2"/>
            <text x="60" y="85" font-size="11" fill="#4CAF50" text-anchor="middle">Start</text>
            <text x="640" y="175" font-size="11" fill="#ff9800" text-anchor="middle">Goal</text>
        </svg>
        <div class="image-caption">Figure 11.2: PRM roadmap with path query. Grey edges form the roadmap; green shows the queried path.</div>
    </div>

    <h3>When to Use PRM vs RRT</h3>
    <table>
        <tr><th>Criterion</th><th>PRM</th><th>RRT / RRT*</th></tr>
        <tr><td>Query type</td><td>Multiple queries, same map</td><td>Single query</td></tr>
        <tr><td>Preprocessing</td><td>Heavy (build roadmap)</td><td>None</td></tr>
        <tr><td>Online speed</td><td>Very fast (graph search)</td><td>Moderate</td></tr>
        <tr><td>Dynamic environments</td><td>Poor (roadmap stale)</td><td>Good (rebuild tree)</td></tr>
        <tr><td>Narrow passages</td><td>May miss without bridge sampling</td><td>Better with goal bias</td></tr>
    </table>

    <div class="tip">
        For drone delivery services where the map is static but destinations change, PRM is ideal. For exploration or dynamic environments, prefer RRT*.
    </div>
</div>

<!-- ==================== PAGE 12: TRAJECTORY OPTIMIZATION ==================== -->
<div class="page">
    <h2>Trajectory Optimization: Minimum Snap</h2>
    <p>Path planners produce waypoints, but drones need smooth, dynamically feasible <strong>trajectories</strong>. The minimum snap formulation produces trajectories that minimize the integral of squared snap (4th derivative of position), resulting in smooth and energy-efficient flight.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1506947411487-a56738571f84?w=900&h=300&fit=crop" alt="Smooth drone flight trajectory">
        <div class="image-caption">Figure 12.1: Smooth trajectories are essential for stable, energy-efficient drone flight</div>
    </div>

    <h3>Why Minimize Snap?</h3>
    <div class="info-box">
        <p>For a quadrotor, <strong>thrust is proportional to snap</strong> (4th derivative of position). Minimizing snap minimizes control effort and produces the smoothest possible trajectory through waypoints. Derivatives:</p>
        <ul>
            <li><strong>Position</strong> \(\mathbf{p}(t)\) -- where the drone is</li>
            <li><strong>Velocity</strong> \(\dot{\mathbf{p}}(t)\) -- how fast it moves</li>
            <li><strong>Acceleration</strong> \(\ddot{\mathbf{p}}(t)\) -- related to tilt angle</li>
            <li><strong>Jerk</strong> \(\dddot{\mathbf{p}}(t)\) -- rate of tilt change</li>
            <li><strong>Snap</strong> \(\mathbf{p}^{(4)}(t)\) -- related to motor thrust changes</li>
        </ul>
    </div>

    <h3>Polynomial Representation</h3>
    <p>Each trajectory segment between consecutive waypoints is represented as a polynomial of degree \(N\) (typically \(N = 7\) for snap minimization, giving 8 coefficients):</p>
    <div class="math">
        \[ p_k(t) = c_{k,0} + c_{k,1}t + c_{k,2}t^2 + \cdots + c_{k,N}t^N = \sum_{j=0}^{N} c_{k,j} \, t^j \]
    </div>
    <p>For \(M\) segments, we have \(M \times (N+1)\) unknown coefficients per axis (x, y, z independently).</p>

    <h3>Snap Minimization Cost Function</h3>
    <div class="math">
        \[ J = \sum_{k=1}^{M} \int_{0}^{T_k} \left\| \frac{d^4 p_k}{dt^4} \right\|^2 dt = \sum_{k=1}^{M} \mathbf{c}_k^T \mathbf{Q}_k \mathbf{c}_k \]
    </div>
    <p>where \(\mathbf{Q}_k\) is the Hessian matrix for segment \(k\), computed analytically from the polynomial basis:</p>
    <div class="math">
        \[ Q_{k,ij} = \begin{cases} \frac{i!\, j!}{(i-4)!(j-4)!} \cdot \frac{T_k^{i+j-7}}{i+j-7} & \text{if } i \geq 4 \text{ and } j \geq 4 \\ 0 & \text{otherwise} \end{cases} \]
    </div>

    <h3>Continuity Constraints</h3>
    <p>At each waypoint, we enforce continuity up to the 3rd derivative (snap is free):</p>
    <div class="math">
        \[ p_k^{(r)}(T_k) = p_{k+1}^{(r)}(0), \quad r = 0, 1, 2, 3 \]
    </div>
    <p>Plus boundary conditions: \(p_1(0) = \mathbf{x}_{\text{start}}\), \(p_M(T_M) = \mathbf{x}_{\text{goal}}\), zero velocity and acceleration at start/end.</p>
</div>

<!-- ==================== PAGE 13: MINIMUM SNAP MATH ==================== -->
<div class="page">
    <h2>Minimum Snap: QP Formulation</h2>
    <p>The full optimization problem is a <strong>Quadratic Program (QP)</strong>:</p>
    <div class="math">
        \[ \min_{\mathbf{c}} \; \mathbf{c}^T \mathbf{Q} \mathbf{c} \quad \text{subject to} \quad \mathbf{A}_{\text{eq}} \mathbf{c} = \mathbf{b}_{\text{eq}} \]
    </div>
    <p>where \(\mathbf{Q} = \text{blkdiag}(\mathbf{Q}_1, \ldots, \mathbf{Q}_M)\) is the block-diagonal cost matrix, and \(\mathbf{A}_{\text{eq}}\) encodes all constraints.</p>

    <h3>Constraint Types</h3>
    <table>
        <tr><th>Constraint</th><th>Count</th><th>Description</th></tr>
        <tr><td>Waypoint positions</td><td>\(M + 1\)</td><td>\(p_k(0) = w_k\) for each waypoint</td></tr>
        <tr><td>Continuity (vel, acc, jerk)</td><td>\(3(M-1)\)</td><td>Derivatives match at junctions</td></tr>
        <tr><td>Boundary velocity</td><td>2</td><td>Start/end velocity = 0</td></tr>
        <tr><td>Boundary acceleration</td><td>2</td><td>Start/end acceleration = 0</td></tr>
        <tr><td><strong>Total</strong></td><td>\(4M + 2\)</td><td>Must equal \(M(N+1)\) unknowns</td></tr>
    </table>
    <p>For \(N=7\) (degree-7 polynomial, 8 coefficients per segment): \(8M\) unknowns, \(4M + 2\) constraints. The remaining degrees of freedom are used to minimize snap.</p>

    <h3>Corridor Constraints (Inequality)</h3>
    <p>To ensure the trajectory stays within a safe corridor around the planned path:</p>
    <div class="math">
        \[ \mathbf{x}_{\min}^{(k)} \leq p_k(t) \leq \mathbf{x}_{\max}^{(k)} \quad \forall t \in [0, T_k] \]
    </div>
    <p>This converts the problem to a <strong>QP with inequality constraints</strong>, solvable with OSQP or qpOASES.</p>

    <h3>Polynomial Segments Visualization</h3>
    <div class="image-container">
        <svg viewBox="0 0 700 280" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <rect x="20" y="20" width="660" height="240" fill="#f9f9f9" stroke="#667eea" stroke-width="1" rx="5"/>
            <!-- Waypoints -->
            <circle cx="60" cy="200" r="8" fill="#4CAF50"/>
            <circle cx="200" cy="80" r="8" fill="#764ba2"/>
            <circle cx="380" cy="150" r="8" fill="#764ba2"/>
            <circle cx="520" cy="60" r="8" fill="#764ba2"/>
            <circle cx="640" cy="180" r="8" fill="#ff9800"/>
            <text x="60" y="230" font-size="11" fill="#4CAF50" text-anchor="middle">w0</text>
            <text x="200" y="70" font-size="11" fill="#764ba2" text-anchor="middle">w1</text>
            <text x="380" y="175" font-size="11" fill="#764ba2" text-anchor="middle">w2</text>
            <text x="520" y="50" font-size="11" fill="#764ba2" text-anchor="middle">w3</text>
            <text x="640" y="210" font-size="11" fill="#ff9800" text-anchor="middle">w4</text>
            <!-- Smooth polynomial curve -->
            <path d="M60,200 C100,160 160,80 200,80 S280,150 380,150 S460,60 520,60 S600,120 640,180" fill="none" stroke="#667eea" stroke-width="3"/>
            <!-- Segment labels -->
            <text x="130" y="120" font-size="12" fill="#667eea">Seg 1</text>
            <text x="290" y="100" font-size="12" fill="#667eea">Seg 2</text>
            <text x="450" y="90" font-size="12" fill="#667eea">Seg 3</text>
            <text x="580" y="140" font-size="12" fill="#667eea">Seg 4</text>
            <!-- Corridor bounds (dashed) -->
            <path d="M60,175 C100,135 160,55 200,55 S280,125 380,125 S460,35 520,35 S600,95 640,155" fill="none" stroke="#ff9800" stroke-width="1" stroke-dasharray="5,5"/>
            <path d="M60,225 C100,185 160,105 200,105 S280,175 380,175 S460,85 520,85 S600,145 640,205" fill="none" stroke="#ff9800" stroke-width="1" stroke-dasharray="5,5"/>
            <text x="350" y="270" font-size="12" fill="#ff9800" text-anchor="middle">Corridor bounds (safety margin)</text>
        </svg>
        <div class="image-caption">Figure 13.1: Minimum snap trajectory through waypoints with corridor constraints</div>
    </div>

    <div class="activity-box">
        <h3>Activity 3: Minimum Snap Trajectory</h3>
        <p><strong>Task:</strong> Given 5 waypoints in 3D space: (0,0,0), (2,1,3), (5,3,2), (7,5,4), (10,6,1) with segment times T = [2, 3, 2, 3] seconds:</p>
        <ol>
            <li>Set up the \(\mathbf{Q}\) matrix for a single segment with degree-7 polynomials.</li>
            <li>Write the equality constraint matrix \(\mathbf{A}_{\text{eq}}\) for waypoint and continuity constraints.</li>
            <li>Solve the QP using <code>scipy.optimize.minimize</code> or <code>cvxpy</code>.</li>
            <li>Plot the resulting 3D trajectory and verify derivative continuity.</li>
        </ol>
    </div>
</div>

<!-- ==================== PAGE 14: TRAJECTORY SMOOTHING & TIME ALLOCATION ==================== -->
<div class="page">
    <h2>Trajectory Smoothing &amp; Time Allocation</h2>

    <h3>Time Parameterization</h3>
    <p>The quality of a minimum snap trajectory depends critically on the <strong>time allocation</strong> \(T_1, T_2, \ldots, T_M\) for each segment. Poor time allocation leads to dynamically infeasible trajectories.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1581092160607-ee22621dd758?w=900&h=300&fit=crop" alt="Time and speed optimization">
        <div class="image-caption">Figure 14.1: Time allocation determines velocity and acceleration profiles along the trajectory</div>
    </div>

    <h3>Initial Time Allocation</h3>
    <p>A common heuristic assigns time proportional to segment distance:</p>
    <div class="math">
        \[ T_k = \frac{\|\mathbf{w}_{k+1} - \mathbf{w}_k\|}{v_{\text{avg}}} \]
    </div>
    <p>where \(v_{\text{avg}}\) is the desired average velocity (typically 1-3 m/s for indoor, 5-15 m/s for outdoor).</p>

    <h3>Feasibility Constraints</h3>
    <p>The trajectory must respect the drone's dynamic limits at all times:</p>
    <div class="math">
        \[ \|\dot{\mathbf{p}}(t)\| \leq v_{\max}, \quad \|\ddot{\mathbf{p}}(t)\| \leq a_{\max}, \quad \|\dddot{\mathbf{p}}(t)\| \leq j_{\max} \]
    </div>

    <div class="two-column">
        <div class="info-box">
            <h4>Typical Multirotor Limits</h4>
            <ul>
                <li>\(v_{\max} = 5\text{-}20\) m/s</li>
                <li>\(a_{\max} = 3\text{-}10\) m/s&sup2;</li>
                <li>\(j_{\max} = 20\text{-}50\) m/s&sup3;</li>
                <li>Max tilt: 30-45 degrees</li>
            </ul>
        </div>
        <div class="info-box">
            <h4>Tilt-Thrust Relationship</h4>
            <p>Horizontal acceleration requires tilting:</p>
            \[ \theta = \arctan\left(\frac{a_{\text{horiz}}}{g + a_z}\right) \]
            <p>This couples horizontal acceleration with altitude control.</p>
        </div>
    </div>

    <h3>Iterative Time Scaling</h3>
    <p>If the trajectory violates dynamic limits, scale the offending segment's time:</p>
    <div class="diagram">
        <div class="flow-step">1. Solve minimum snap with initial T_k values</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">2. Evaluate max velocity, acceleration, jerk on each segment</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">3. For each violating segment: T_k *= max(v/v_max, sqrt(a/a_max), cbrt(j/j_max))</div>
        <div class="arrow">&darr;</div>
        <div class="flow-step">4. Re-solve and repeat until feasible (typically 2-4 iterations)</div>
    </div>

    <h3>Advanced: Joint Time-Trajectory Optimization</h3>
    <p>For the best results, optimize segment times jointly with polynomial coefficients:</p>
    <div class="math">
        \[ \min_{\mathbf{c}, \mathbf{T}} \; \sum_{k=1}^{M} \int_0^{T_k} \left\| p_k^{(4)}(t) \right\|^2 dt + \rho \sum_{k=1}^{M} T_k \]
    </div>
    <p>The penalty term \(\rho \sum T_k\) discourages unnecessarily slow trajectories. This is a non-convex problem solved with gradient descent or NLP solvers.</p>

    <div class="tip">
        Start with the trapezoidal time heuristic, solve the QP, then run 2-3 iterations of time scaling. This gives near-optimal results without the complexity of joint optimization.
    </div>
</div>

<!-- ==================== PAGE 15: DYNAMIC OBSTACLES & REPLANNING ==================== -->
<div class="page">
    <h2>Dynamic Obstacles &amp; Replanning</h2>
    <p>Real-world drone operations involve moving obstacles: other drones, birds, vehicles. The planner must detect conflicts and replan in real time.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1559827260-dc66d52bef19?w=900&h=300&fit=crop" alt="Dynamic urban environment">
        <div class="image-caption">Figure 15.1: Dynamic environments require continuous replanning and obstacle avoidance</div>
    </div>

    <h3>Velocity Obstacles (VO)</h3>
    <p>A velocity obstacle defines the set of velocities that will lead to a collision with a moving obstacle within a time horizon \(\tau\):</p>
    <div class="math">
        \[ VO_B^A = \left\{ \mathbf{v}_A \;\middle|\; \exists t \in [0, \tau] : \mathbf{p}_A + \mathbf{v}_A t \in D(\mathbf{p}_B + \mathbf{v}_B t, r_A + r_B) \right\} \]
    </div>
    <p><strong>where:</strong></p>
    <ul>
        <li>\( VO_B^A \) — velocity obstacle induced by agent \(B\) on agent \(A\)</li>
        <li>\( \mathbf{v}_A, \mathbf{v}_B \) — velocities of agents \(A\) and \(B\)</li>
        <li>\( \mathbf{p}_A, \mathbf{p}_B \) — positions of agents \(A\) and \(B\)</li>
        <li>\( r_A, r_B \) — bounding radii of agents \(A\) and \(B\)</li>
        <li>\( D(\mathbf{c}, r) \) — disc (ball) centred at \(\mathbf{c}\) with radius \(r\)</li>
        <li>\( \tau \) — time horizon for collision checking</li>
    </ul>

    <div class="image-container">
        <svg viewBox="0 0 700 280" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <rect x="10" y="10" width="680" height="260" fill="#f9f9f9" stroke="#667eea" stroke-width="1" rx="5"/>
            <!-- Velocity space label -->
            <text x="350" y="35" font-size="14" font-weight="bold" fill="#667eea" text-anchor="middle">Velocity Space</text>
            <!-- Origin -->
            <circle cx="200" cy="160" r="4" fill="#333"/>
            <text x="200" y="185" font-size="11" fill="#333" text-anchor="middle">v_A = 0</text>
            <!-- Axes -->
            <line x1="100" y1="160" x2="350" y2="160" stroke="#ccc" stroke-width="1"/>
            <line x1="200" y1="60" x2="200" y2="240" stroke="#ccc" stroke-width="1"/>
            <text x="355" y="165" font-size="10" fill="#ccc">vx</text>
            <text x="205" y="55" font-size="10" fill="#ccc">vy</text>
            <!-- VO cone -->
            <polygon points="200,160 350,60 350,140" fill="#e74c3c" opacity="0.2"/>
            <line x1="200" y1="160" x2="350" y2="60" stroke="#e74c3c" stroke-width="2"/>
            <line x1="200" y1="160" x2="350" y2="140" stroke="#e74c3c" stroke-width="2"/>
            <text x="320" y="90" font-size="12" fill="#e74c3c" font-weight="bold">VO</text>
            <!-- Relative velocity of obstacle -->
            <circle cx="300" cy="100" r="20" fill="#e74c3c" opacity="0.3" stroke="#e74c3c" stroke-width="1"/>
            <text x="300" y="105" font-size="10" fill="#e74c3c" text-anchor="middle">B</text>
            <!-- Safe velocity -->
            <line x1="200" y1="160" x2="280" y2="200" stroke="#4CAF50" stroke-width="3" marker-end="url(#arrowGreen)"/>
            <text x="280" y="220" font-size="11" fill="#4CAF50" text-anchor="middle">Safe v_A</text>
            <!-- Collision velocity -->
            <line x1="200" y1="160" x2="300" y2="100" stroke="#e74c3c" stroke-width="2" stroke-dasharray="5,3" marker-end="url(#arrowRed)"/>
            <text x="265" y="120" font-size="11" fill="#e74c3c">Collision!</text>
            <defs>
                <marker id="arrowGreen" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="#4CAF50"/></marker>
                <marker id="arrowRed" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto"><path d="M 0 0 L 10 5 L 0 10 z" fill="#e74c3c"/></marker>
            </defs>
            <!-- Legend -->
            <rect x="430" y="60" width="230" height="170" fill="white" stroke="#667eea" stroke-width="1" rx="5"/>
            <text x="545" y="85" font-size="13" font-weight="bold" fill="#667eea" text-anchor="middle">Key Concepts</text>
            <text x="445" y="110" font-size="11" fill="#333">Red cone: Velocity Obstacle</text>
            <text x="445" y="130" font-size="11" fill="#333">Any v_A in VO leads to collision</text>
            <text x="445" y="155" font-size="11" fill="#4CAF50">Green: safe velocity choice</text>
            <text x="445" y="180" font-size="11" fill="#333">ORCA: reciprocal variant for</text>
            <text x="445" y="200" font-size="11" fill="#333">multi-agent collision avoidance</text>
        </svg>
        <div class="image-caption">Figure 15.2: Velocity Obstacle (VO) in 2D velocity space. The drone must choose a velocity outside the VO cone.</div>
    </div>

    <h3>D* Lite for Replanning</h3>
    <p>D* Lite is an incremental search algorithm that efficiently repairs a previous solution when the map changes:</p>
    <ul>
        <li>Maintains a search tree from the goal toward the robot</li>
        <li>When obstacles are detected, only affected nodes are re-expanded</li>
        <li>Much faster than re-running A* from scratch (typically 10-100x)</li>
        <li>Ideal for drones with forward-looking sensors discovering new obstacles</li>
    </ul>

    <h3>When to Replan?</h3>
    <div class="two-column">
        <div class="warning-box">
            <h4>Trigger Replanning When:</h4>
            <ul>
                <li>New obstacle detected on current path</li>
                <li>Obstacle moved closer than safety margin</li>
                <li>Significant deviation from planned trajectory</li>
                <li>Battery level requires shorter path to home</li>
            </ul>
        </div>
        <div class="info-box">
            <h4>Avoid Replanning When:</h4>
            <ul>
                <li>Obstacle is far from current path</li>
                <li>Minor map updates in irrelevant areas</li>
                <li>Currently in a critical manoeuvre (landing)</li>
                <li>Replanning frequency exceeds control rate</li>
            </ul>
        </div>
    </div>
</div>

<!-- ==================== PAGE 16: ENERGY-AWARE PLANNING ==================== -->
<div class="page">
    <h2>Energy-Aware Planning</h2>
    <p>Battery life is the primary constraint for drone operations. An energy-aware planner considers the actual energy cost of each trajectory segment, not just geometric distance.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1620712943543-bcc4688e7485?w=900&h=300&fit=crop" alt="Battery and energy concept">
        <div class="image-caption">Figure 16.1: Energy constraints fundamentally shape drone path planning decisions</div>
    </div>

    <h3>Energy Consumption Model</h3>
    <p>The power consumption of a multirotor depends on velocity, acceleration, and altitude:</p>
    <div class="math">
        \[ P(t) = P_{\text{hover}} + P_{\text{drag}}(v) + P_{\text{climb}}(v_z) + P_{\text{accel}}(a) \]
    </div>
    <p>Expanded model:</p>
    <div class="math">
        \[ P(t) = \frac{mg}{\eta_{\text{prop}}} \sqrt{\frac{mg}{2\rho A}} + \frac{1}{2} C_D \rho A_f v^3 + mg \, v_z + m \, \mathbf{v} \cdot \mathbf{a} \]
    </div>
    <p><strong>where:</strong></p>
    <ul>
        <li>\( m \) — drone mass, \( g \) — gravitational acceleration</li>
        <li>\( \eta_{\text{prop}} \) — propeller efficiency</li>
        <li>\( \rho \) — air density, \( A \) — total propeller disc area</li>
        <li>\( C_D \) — drag coefficient, \( A_f \) — frontal area</li>
        <li>\( v \) — airspeed magnitude, \( v_z \) — vertical velocity (positive = climbing)</li>
        <li>\( \mathbf{v}, \mathbf{a} \) — velocity and acceleration vectors</li>
    </ul>
    <p>Total energy for a trajectory:</p>
    <div class="math">
        \[ E = \int_0^{T_{\text{total}}} P(t) \, dt \]
    </div>

    <h3>Key Variables</h3>
    <table>
        <tr><th>Symbol</th><th>Description</th><th>Typical Value</th></tr>
        <tr><td>\(m\)</td><td>Drone mass</td><td>1.5 - 5 kg</td></tr>
        <tr><td>\(g\)</td><td>Gravity</td><td>9.81 m/s&sup2;</td></tr>
        <tr><td>\(\eta_{\text{prop}}\)</td><td>Propulsion efficiency</td><td>0.5 - 0.7</td></tr>
        <tr><td>\(\rho\)</td><td>Air density</td><td>1.225 kg/m&sup3;</td></tr>
        <tr><td>\(A\)</td><td>Total rotor disk area</td><td>0.1 - 0.5 m&sup2;</td></tr>
        <tr><td>\(C_D\)</td><td>Drag coefficient</td><td>0.3 - 0.5</td></tr>
        <tr><td>\(A_f\)</td><td>Frontal area</td><td>0.02 - 0.1 m&sup2;</td></tr>
    </table>

    <h3>Altitude vs Energy Tradeoff</h3>
    <div class="two-column">
        <div>
            <h4>Climbing Costs Energy</h4>
            <p>Gaining altitude requires work against gravity: \(E_{\text{climb}} = mgh\). For a 3 kg drone climbing 50 m: \(E = 3 \times 9.81 \times 50 = 1471\) J &asymp; 0.4 Wh.</p>
            <p>This is ~2% of a typical 6S 5000 mAh battery (88 Wh).</p>
        </div>
        <div>
            <h4>But Higher Can Be Shorter</h4>
            <p>Flying over an obstacle at higher altitude may be <strong>shorter</strong> than flying around it. The planner must evaluate:</p>
            <div class="math">
                \[ E_{\text{over}} = E_{\text{climb}} + E_{\text{cruise,short}} \]
                \[ E_{\text{around}} = E_{\text{cruise,long}} \]
            </div>
        </div>
    </div>

    <h3>Wind Effects</h3>
    <div class="info-box">
        <p>Wind modifies the ground speed: \(\mathbf{v}_{\text{ground}} = \mathbf{v}_{\text{air}} + \mathbf{v}_{\text{wind}}\). Energy-aware planners can use wind forecasts to:</p>
        <ul>
            <li>Prefer tailwind routes (even if geometrically longer)</li>
            <li>Avoid headwind corridors</li>
            <li>Choose altitudes with favorable wind profiles</li>
        </ul>
    </div>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1534996858221-380b92700493?w=900&h=250&fit=crop" alt="Wind and drone flight">
        <div class="image-caption">Figure 16.2: Wind significantly affects drone energy consumption and must be considered in planning</div>
    </div>
</div>

<!-- ==================== PAGE 17: GEOFENCING & NO-FLY ZONES ==================== -->
<div class="page">
    <h2>Geofencing &amp; No-Fly Zones</h2>
    <p>Geofencing defines virtual boundaries that drones must respect. These are critical for regulatory compliance and safety.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1436491865332-7a61a109db05?w=900&h=300&fit=crop" alt="Airspace and no-fly zones">
        <div class="image-caption">Figure 17.1: Airspace management requires strict geofence compliance</div>
    </div>

    <h3>Geofence Types</h3>
    <div class="image-container">
        <svg viewBox="0 0 700 320" style="width:100%;height:auto;" xmlns="http://www.w3.org/2000/svg">
            <!-- Polygon geofence -->
            <text x="120" y="25" font-size="14" font-weight="bold" fill="#667eea" text-anchor="middle">Polygon Geofence</text>
            <polygon points="30,60 210,50 230,200 160,250 40,220" fill="#e74c3c" opacity="0.15" stroke="#e74c3c" stroke-width="2"/>
            <text x="120" y="140" font-size="12" fill="#e74c3c" text-anchor="middle">No-Fly Zone</text>
            <text x="120" y="280" font-size="11" fill="#666" text-anchor="middle">2D polygon projected vertically</text>

            <!-- Cylinder geofence -->
            <text x="370" y="25" font-size="14" font-weight="bold" fill="#764ba2" text-anchor="middle">Cylindrical Geofence</text>
            <ellipse cx="370" cy="80" rx="80" ry="25" fill="none" stroke="#764ba2" stroke-width="2"/>
            <ellipse cx="370" cy="220" rx="80" ry="25" fill="#764ba2" opacity="0.15" stroke="#764ba2" stroke-width="2"/>
            <line x1="290" y1="80" x2="290" y2="220" stroke="#764ba2" stroke-width="2"/>
            <line x1="450" y1="80" x2="450" y2="220" stroke="#764ba2" stroke-width="2"/>
            <text x="370" y="155" font-size="12" fill="#764ba2" text-anchor="middle">Airport Zone</text>
            <text x="370" y="175" font-size="10" fill="#764ba2" text-anchor="middle">r = 5 km, h = 120 m</text>
            <text x="370" y="280" font-size="11" fill="#666" text-anchor="middle">Center + radius + altitude range</text>

            <!-- Keep-in box -->
            <text x="590" y="25" font-size="14" font-weight="bold" fill="#4CAF50" text-anchor="middle">Keep-In Box</text>
            <rect x="510" y="50" width="160" height="200" fill="#4CAF50" opacity="0.1" stroke="#4CAF50" stroke-width="2" stroke-dasharray="8,4"/>
            <text x="590" y="140" font-size="12" fill="#4CAF50" text-anchor="middle">Operational</text>
            <text x="590" y="160" font-size="12" fill="#4CAF50" text-anchor="middle">Volume</text>
            <circle cx="560" cy="120" r="5" fill="#667eea"/>
            <text x="560" y="110" font-size="9" fill="#667eea" text-anchor="middle">Drone</text>
            <text x="590" y="280" font-size="11" fill="#666" text-anchor="middle">Drone must stay inside</text>
        </svg>
        <div class="image-caption">Figure 17.2: Three types of geofences used in drone operations</div>
    </div>

    <h3>Altitude Restrictions</h3>
    <div class="info-box">
        <p>Altitude geofences create layered airspace:</p>
        <ul>
            <li><strong>Class G (uncontrolled):</strong> 0 - 120 m AGL (most drone operations)</li>
            <li><strong>Near airports:</strong> graduated altitude limits (e.g., 0 m within 1 km, increases with distance)</li>
            <li><strong>UTM corridors:</strong> designated altitude bands for drone traffic (e.g., 50-60 m eastbound, 70-80 m westbound)</li>
        </ul>
    </div>

    <h3>UAS Traffic Management (UTM)</h3>
    <p>UTM systems manage drone traffic in low-altitude airspace:</p>
    <div class="three-column">
        <div class="sensor-card">
            <h4>Flight Authorization</h4>
            <p>Pre-flight approval with intended 4D trajectory (x, y, z, t)</p>
        </div>
        <div class="sensor-card">
            <h4>Conflict Detection</h4>
            <p>Server-side deconfliction with other planned flights</p>
        </div>
        <div class="sensor-card">
            <h4>Dynamic Restrictions</h4>
            <p>Real-time TFRs, emergency vehicle corridors, weather</p>
        </div>
    </div>

    <h3>Integrating Geofences into Planning</h3>
    <p>Geofences become hard constraints in the planner:</p>
    <ul>
        <li><strong>Grid-based:</strong> mark geofence voxels as occupied before planning</li>
        <li><strong>Sampling-based:</strong> reject samples and edges that intersect geofences</li>
        <li><strong>Trajectory optimization:</strong> add inequality constraints for geofence boundaries</li>
    </ul>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1517483000871-1dbf64a6e1c6?w=900&h=250&fit=crop" alt="Urban airspace management">
        <div class="image-caption">Figure 17.3: Future urban airspace will require sophisticated geofence-aware planning</div>
    </div>
</div>

<!-- ==================== PAGE 18: ROS 2 INTEGRATION ==================== -->
<div class="page">
    <h2>ROS 2 Integration for 3D Path Planning</h2>
    <p>ROS 2 provides a rich ecosystem for 3D drone planning. Key packages include OctoMap for mapping, Nav2 for navigation, and OMPL for sampling-based planning.</p>

    <div class="image-container">
        <img src="https://images.unsplash.com/photo-1555949963-ff9fe0c870eb?w=900&h=300&fit=crop" alt="Software development and code">
        <div class="image-caption">Figure 18.1: ROS 2 provides the middleware for integrating perception, planning, and control</div>
    </div>

    <h3>OctoMap Server in ROS 2</h3>
    <pre>
# Install octomap packages
sudo apt install ros-humble-octomap ros-humble-octomap-server \
    ros-humble-octomap-msgs ros-humble-octomap-rviz-plugins

# Launch octomap_server with point cloud input
ros2 run octomap_server octomap_server_node --ros-args \
    -p resolution:=0.15 \
    -p frame_id:=map \
    -p sensor_model.max_range:=10.0 \
    -r cloud_in:=/drone/depth/points
    </pre>

    <h3>Custom 3D Planner Node</h3>
    <pre>
import rclpy
from rclpy.node import Node
from octomap_msgs.msg import Octomap
from nav_msgs.msg import Path
from geometry_msgs.msg import PoseStamped
import numpy as np

class Drone3DPlanner(Node):
    def __init__(self):
        super().__init__('drone_3d_planner')
        self.octomap_sub = self.create_subscription(
            Octomap, '/octomap_binary', self.octomap_cb, 10)
        self.path_pub = self.create_publisher(Path, '/planned_path', 10)
        self.goal_sub = self.create_subscription(
            PoseStamped, '/goal_pose', self.goal_cb, 10)
        self.octomap = None

    def octomap_cb(self, msg):
        self.octomap = msg  # Store latest map

    def goal_cb(self, msg):
        if self.octomap is None:
            self.get_logger().warn('No octomap received yet')
            return
        goal = [msg.pose.position.x,
                msg.pose.position.y,
                msg.pose.position.z]
        # Run RRT* in octomap (simplified)
        waypoints = self.plan_rrt_star(goal)
        self.publish_path(waypoints)

    def plan_rrt_star(self, goal):
        # ... RRT* implementation using octomap for
        # collision checking ...
        return waypoints

    def publish_path(self, waypoints):
        path = Path()
        path.header.frame_id = 'map'
        path.header.stamp = self.get_clock().now().to_msg()
        for wp in waypoints:
            pose = PoseStamped()
            pose.pose.position.x = wp[0]
            pose.pose.position.y = wp[1]
            pose.pose.position.z = wp[2]
            path.poses.append(pose)
        self.path_pub.publish(path)
    </pre>

    <h3>Key ROS 2 Packages for 3D Drone Planning</h3>
    <table>
        <tr><th>Package</th><th>Purpose</th><th>Key Topics/Services</th></tr>
        <tr><td><code>octomap_server</code></td><td>3D occupancy mapping</td><td><code>/octomap_binary</code>, <code>/octomap_full</code></td></tr>
        <tr><td><code>nav2</code></td><td>Navigation stack (extendable to 3D)</td><td><code>/plan</code>, <code>/follow_path</code></td></tr>
        <tr><td><code>moveit2</code></td><td>Motion planning (manipulation drones)</td><td><code>/move_group</code>, OMPL integration</td></tr>
        <tr><td><code>px4_ros_com</code></td><td>PX4 flight controller interface</td><td><code>/fmu/in/trajectory_setpoint</code></td></tr>
        <tr><td><code>tf2</code></td><td>Coordinate transforms</td><td>map &rarr; odom &rarr; base_link</td></tr>
    </table>

    <div class="activity-box">
        <h3>Activity 4: ROS 2 OctoMap Planning Pipeline</h3>
        <p><strong>Task:</strong> Build a complete 3D planning pipeline in ROS 2:</p>
        <ol>
            <li>Launch Gazebo with a drone and 3D obstacles</li>
            <li>Configure <code>octomap_server</code> to build a 3D map from the drone's depth camera</li>
            <li>Implement an RRT* planner node that subscribes to the OctoMap and publishes paths</li>
            <li>Apply minimum snap trajectory optimization to the waypoints</li>
            <li>Send trajectory setpoints to the PX4 flight controller</li>
        </ol>
    </div>
</div>

<!-- ==================== PAGE 19: SUMMARY & LAB PREVIEW ==================== -->
<div class="page">
    <h2>Summary</h2>

    <div class="info-box">
        <h3>Key Takeaways</h3>
        <ul>
            <li><strong>3D representations:</strong> Octrees (OctoMap) are the standard for memory-efficient 3D mapping</li>
            <li><strong>Graph-based (3D A*):</strong> Optimal but scales poorly beyond ~200&sup3; grids</li>
            <li><strong>Sampling-based (RRT, RRT*, PRM):</strong> Scale to high dimensions; RRT* is asymptotically optimal</li>
            <li><strong>Trajectory optimization:</strong> Minimum snap produces smooth, dynamically feasible trajectories</li>
            <li><strong>Dynamic environments:</strong> D* Lite for replanning; velocity obstacles for collision avoidance</li>
            <li><strong>Energy &amp; geofencing:</strong> Real-world constraints that shape practical drone planning</li>
        </ul>
    </div>

    <h3>Lab Preview: 7 Tasks</h3>
    <ol>
        <li><strong>Task 1:</strong> Build a 3D voxel grid and OctoMap from point cloud data</li>
        <li><strong>Task 2:</strong> Implement 3D A* with 26-connected neighbors</li>
        <li><strong>Task 3:</strong> Implement RRT for a 3D drone environment</li>
        <li><strong>Task 4:</strong> Implement RRT* with rewiring and compare path quality to RRT</li>
        <li><strong>Task 5:</strong> Solve a minimum snap trajectory optimization through 5 waypoints</li>
        <li><strong>Task 6:</strong> Add geofence constraints (no-fly cylinder) to the planner</li>
        <li><strong>Task 7:</strong> Integrate the full pipeline in ROS 2 with OctoMap and Gazebo</li>
    </ol>

    <h3>Key Equations Reference Card</h3>
    <table>
        <tr><th>Equation</th><th>Purpose</th></tr>
        <tr><td>\(h(\mathbf{n}) = \|\mathbf{n} - \mathbf{g}\|_2\)</td><td>3D Euclidean heuristic</td></tr>
        <tr><td>\(L(n|z_{1:t}) = L(n|z_{1:t-1}) + L(n|z_t) - L_0\)</td><td>OctoMap log-odds update</td></tr>
        <tr><td>\(r_n = \gamma(\log n / n)^{1/d}\)</td><td>RRT* rewiring radius</td></tr>
        <tr><td>\(J = \sum \int \|p^{(4)}(t)\|^2 dt\)</td><td>Minimum snap cost</td></tr>
        <tr><td>\(P = P_{\text{hover}} + P_{\text{drag}} + P_{\text{climb}} + P_{\text{accel}}\)</td><td>Energy model</td></tr>
    </table>

    <h3>Algorithm Comparison</h3>
    <table>
        <tr><th>Algorithm</th><th>Optimal</th><th>Complete</th><th>Speed</th><th>Memory</th></tr>
        <tr><td>3D A*</td><td>Yes</td><td>Yes</td><td>Medium</td><td>High</td></tr>
        <tr><td>RRT</td><td>No</td><td>Prob. Yes</td><td>Fast</td><td>Low</td></tr>
        <tr><td>RRT*</td><td>Asymptotic</td><td>Prob. Yes</td><td>Medium</td><td>Medium</td></tr>
        <tr><td>Informed RRT*</td><td>Asymptotic</td><td>Prob. Yes</td><td>Fast</td><td>Medium</td></tr>
        <tr><td>BIT*</td><td>Asymptotic</td><td>Prob. Yes</td><td>Fastest</td><td>Medium</td></tr>
        <tr><td>PRM</td><td>Asymptotic</td><td>Prob. Yes</td><td>Fast (query)</td><td>High</td></tr>
        <tr><td>D* Lite</td><td>Yes</td><td>Yes</td><td>Fast (replan)</td><td>High</td></tr>
    </table>

    <h3>Interview Questions</h3>
    <ol>
        <li>Why is an octree more memory-efficient than a voxel grid for 3D mapping?</li>
        <li>Explain the difference between RRT and RRT*. What guarantees does RRT* provide?</li>
        <li>What is the minimum snap trajectory and why is it preferred for quadrotors?</li>
        <li>How does D* Lite differ from re-running A* when the map changes?</li>
        <li>Describe how you would integrate geofence constraints into a sampling-based planner.</li>
        <li>What is the velocity obstacle and how is it used for dynamic collision avoidance?</li>
        <li>Compare PRM and RRT for multi-query vs single-query planning scenarios.</li>
    </ol>
</div>

</body>
</html>